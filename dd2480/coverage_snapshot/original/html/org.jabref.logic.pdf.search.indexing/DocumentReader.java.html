<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DocumentReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.pdf.search.indexing</a> &gt; <span class="el_source">DocumentReader.java</span></div><h1>DocumentReader.java</h1><pre class="source lang-java linenums">package org.jabref.logic.pdf.search.indexing;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.jabref.gui.LibraryTab;
import org.jabref.model.database.BibDatabaseContext;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.LinkedFile;
import org.jabref.model.strings.StringUtil;
import org.jabref.preferences.FilePreferences;

import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.document.StringField;
import org.apache.lucene.document.TextField;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDPage;
import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;
import org.apache.pdfbox.text.PDFTextStripper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import static org.jabref.model.pdf.search.SearchFieldConstants.ANNOTATIONS;
import static org.jabref.model.pdf.search.SearchFieldConstants.CONTENT;
import static org.jabref.model.pdf.search.SearchFieldConstants.MODIFIED;
import static org.jabref.model.pdf.search.SearchFieldConstants.PAGE_NUMBER;
import static org.jabref.model.pdf.search.SearchFieldConstants.PATH;

/**
 * Utility class for reading the data from LinkedFiles of a BibEntry for Lucene.
 */
public final class DocumentReader {

<span class="fc" id="L43">    private static final Logger LOGGER = LoggerFactory.getLogger(LibraryTab.class);</span>

<span class="fc" id="L45">    private static final Pattern HYPHEN_LINEBREAK_PATTERN = Pattern.compile(&quot;\\-\n&quot;);</span>
<span class="fc" id="L46">    private static final Pattern LINEBREAK_WITHOUT_PERIOD_PATTERN = Pattern.compile(&quot;([^\\\\.])\\n&quot;);</span>

    private final BibEntry entry;
    private final FilePreferences filePreferences;

    /**
     * Creates a new DocumentReader using a BibEntry.
     *
     * @param bibEntry Must not be null and must have at least one LinkedFile.
     */
<span class="fc" id="L56">    public DocumentReader(BibEntry bibEntry, FilePreferences filePreferences) {</span>
<span class="fc" id="L57">        this.filePreferences = filePreferences;</span>
<span class="pc bpc" id="L58" title="1 of 2 branches missed.">        if (bibEntry.getFiles().isEmpty()) {</span>
<span class="nc" id="L59">            throw new IllegalStateException(&quot;There are no linked PDF files to this BibEntry!&quot;);</span>
        }

<span class="fc" id="L62">        this.entry = bibEntry;</span>
<span class="fc" id="L63">    }</span>

    /**
     * Reads a LinkedFile of a BibEntry and converts it into a Lucene Document which is then returned.
     *
     * @return An Optional of a Lucene Document with the (meta)data. Can be empty if there is a problem reading the LinkedFile.
     */
    public Optional&lt;List&lt;Document&gt;&gt; readLinkedPdf(BibDatabaseContext databaseContext, LinkedFile pdf) {
<span class="fc" id="L71">        Optional&lt;Path&gt; pdfPath = pdf.findIn(databaseContext, filePreferences);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        if (pdfPath.isPresent()) {</span>
            try {
<span class="fc" id="L74">                return Optional.of(readPdfContents(pdf, pdfPath.get()));</span>
<span class="nc" id="L75">            } catch (IOException e) {</span>
<span class="nc" id="L76">                LOGGER.error(&quot;Could not read pdf file {}!&quot;, pdf.getLink(), e);</span>
            }
        }
<span class="fc" id="L79">        return Optional.empty();</span>
    }

    /**
     * Reads each LinkedFile of a BibEntry and converts them into Lucene Documents which are then returned.
     *
     * @return A List of Documents with the (meta)data. Can be empty if there is a problem reading the LinkedFile.
     */
    public List&lt;Document&gt; readLinkedPdfs(BibDatabaseContext databaseContext) {
<span class="fc" id="L88">        return entry.getFiles().stream()</span>
<span class="fc" id="L89">                    .map((pdf) -&gt; readLinkedPdf(databaseContext, pdf))</span>
<span class="fc" id="L90">                    .filter(Optional::isPresent)</span>
<span class="fc" id="L91">                    .map(Optional::get)</span>
<span class="fc" id="L92">                    .flatMap(List::stream)</span>
<span class="fc" id="L93">                    .collect(Collectors.toList());</span>
    }

    private List&lt;Document&gt; readPdfContents(LinkedFile pdf, Path resolvedPdfPath) throws IOException {
<span class="fc" id="L97">        try (PDDocument pdfDocument = PDDocument.load(resolvedPdfPath.toFile())) {</span>
<span class="fc" id="L98">            List&lt;Document&gt; pages = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L100" title="All 2 branches covered.">            for (int pageNumber = 0; pageNumber &lt; pdfDocument.getNumberOfPages(); pageNumber++) {</span>
<span class="fc" id="L101">                Document newDocument = new Document();</span>
<span class="fc" id="L102">                addIdentifiers(newDocument, pdf.getLink());</span>
<span class="fc" id="L103">                addMetaData(newDocument, resolvedPdfPath, pageNumber);</span>
<span class="fc" id="L104">                addContentIfNotEmpty(pdfDocument, newDocument, pageNumber);</span>
<span class="fc" id="L105">                pages.add(newDocument);</span>
            }
<span class="fc" id="L107">            return pages;</span>
        }
    }

    private void addMetaData(Document newDocument, Path resolvedPdfPath, int pageNumber) {
        try {
<span class="fc" id="L113">            BasicFileAttributes attributes = Files.readAttributes(resolvedPdfPath, BasicFileAttributes.class);</span>
<span class="fc" id="L114">            addStringField(newDocument, MODIFIED, String.valueOf(attributes.lastModifiedTime().to(TimeUnit.SECONDS)));</span>
<span class="nc" id="L115">        } catch (IOException e) {</span>
<span class="nc" id="L116">            LOGGER.error(&quot;Could not read timestamp for {}&quot;, resolvedPdfPath, e);</span>
<span class="fc" id="L117">        }</span>
<span class="fc" id="L118">        addStringField(newDocument, PAGE_NUMBER, String.valueOf(pageNumber));</span>
<span class="fc" id="L119">    }</span>

    private void addStringField(Document newDocument, String field, String value) {
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">        if (!isValidField(value)) {</span>
<span class="nc" id="L123">            return;</span>
        }
<span class="fc" id="L125">        newDocument.add(new StringField(field, value, Field.Store.YES));</span>
<span class="fc" id="L126">    }</span>

    private boolean isValidField(String value) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        return !(StringUtil.isNullOrEmpty(value));</span>
    }

    public static String mergeLines(String text) {
<span class="fc" id="L133">        String mergedHyphenNewlines = HYPHEN_LINEBREAK_PATTERN.matcher(text).replaceAll(&quot;&quot;);</span>
<span class="fc" id="L134">        return LINEBREAK_WITHOUT_PERIOD_PATTERN.matcher(mergedHyphenNewlines).replaceAll(&quot;$1 &quot;);</span>
    }

    private void addContentIfNotEmpty(PDDocument pdfDocument, Document newDocument, int pageNumber) {
        try {
<span class="fc" id="L139">            PDFTextStripper pdfTextStripper = new PDFTextStripper();</span>
<span class="fc" id="L140">            pdfTextStripper.setLineSeparator(&quot;\n&quot;);</span>
<span class="fc" id="L141">            pdfTextStripper.setStartPage(pageNumber);</span>
<span class="fc" id="L142">            pdfTextStripper.setEndPage(pageNumber);</span>

<span class="fc" id="L144">            String pdfContent = pdfTextStripper.getText(pdfDocument);</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">            if (StringUtil.isNotBlank(pdfContent)) {</span>
<span class="fc" id="L146">                newDocument.add(new TextField(CONTENT, mergeLines(pdfContent), Field.Store.YES));</span>
            }
<span class="fc" id="L148">            PDPage page = pdfDocument.getPage(pageNumber);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            List&lt;String&gt; annotations = page.getAnnotations().stream().filter((annotation) -&gt; annotation.getContents() != null).map(PDAnnotation::getContents).collect(Collectors.toList());</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">            if (annotations.size() &gt; 0) {</span>
<span class="fc" id="L151">                newDocument.add(new TextField(ANNOTATIONS, annotations.stream().collect(Collectors.joining(&quot;\n&quot;)), Field.Store.YES));</span>
            }
<span class="nc" id="L153">        } catch (IOException e) {</span>
<span class="nc" id="L154">            LOGGER.info(&quot;Could not read contents of PDF document \&quot;{}\&quot;&quot;, pdfDocument.toString(), e);</span>
<span class="fc" id="L155">        }</span>
<span class="fc" id="L156">    }</span>

    private void addIdentifiers(Document newDocument, String path) {
<span class="fc" id="L159">        newDocument.add(new StringField(PATH, path, Field.Store.YES));</span>
<span class="fc" id="L160">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>