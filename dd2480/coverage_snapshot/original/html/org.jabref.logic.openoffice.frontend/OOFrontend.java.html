<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OOFrontend.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.openoffice.frontend</a> &gt; <span class="el_source">OOFrontend.java</span></div><h1>OOFrontend.java</h1><pre class="source lang-java linenums">package org.jabref.logic.openoffice.frontend;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

import org.jabref.logic.JabRefException;
import org.jabref.logic.l10n.Localization;
import org.jabref.logic.openoffice.backend.Backend52;
import org.jabref.model.openoffice.CitationEntry;
import org.jabref.model.openoffice.ootext.OOText;
import org.jabref.model.openoffice.rangesort.FunctionalTextViewCursor;
import org.jabref.model.openoffice.rangesort.RangeOverlap;
import org.jabref.model.openoffice.rangesort.RangeOverlapBetween;
import org.jabref.model.openoffice.rangesort.RangeOverlapWithin;
import org.jabref.model.openoffice.rangesort.RangeSort;
import org.jabref.model.openoffice.rangesort.RangeSortEntry;
import org.jabref.model.openoffice.rangesort.RangeSortVisual;
import org.jabref.model.openoffice.rangesort.RangeSortable;
import org.jabref.model.openoffice.style.CitationGroup;
import org.jabref.model.openoffice.style.CitationGroupId;
import org.jabref.model.openoffice.style.CitationGroups;
import org.jabref.model.openoffice.style.CitationType;
import org.jabref.model.openoffice.style.OODataModel;
import org.jabref.model.openoffice.uno.CreationException;
import org.jabref.model.openoffice.uno.NoDocumentException;
import org.jabref.model.openoffice.uno.UnoCursor;
import org.jabref.model.openoffice.uno.UnoTextRange;
import org.jabref.model.openoffice.util.OOListUtil;
import org.jabref.model.openoffice.util.OOVoidResult;

import com.sun.star.beans.IllegalTypeException;
import com.sun.star.beans.NotRemoveableException;
import com.sun.star.beans.PropertyVetoException;
import com.sun.star.lang.WrappedTargetException;
import com.sun.star.text.XTextCursor;
import com.sun.star.text.XTextDocument;
import com.sun.star.text.XTextRange;

public class OOFrontend {

    public final Backend52 backend;
    public final CitationGroups citationGroups;

    public OOFrontend(XTextDocument doc)
        throws
        NoDocumentException,
<span class="nc" id="L52">        WrappedTargetException {</span>

        // TODO: dataModel should come from looking at the document and preferences.
<span class="nc" id="L55">        this.backend = new Backend52();</span>

        // Get the citationGroupNames
<span class="nc" id="L58">        List&lt;String&gt; citationGroupNames = this.backend.getJabRefReferenceMarkNames(doc);</span>

<span class="nc" id="L60">        Map&lt;CitationGroupId, CitationGroup&gt; citationGroups =</span>
<span class="nc" id="L61">            readCitationGroupsFromDocument(this.backend, doc, citationGroupNames);</span>
<span class="nc" id="L62">        this.citationGroups = new CitationGroups(citationGroups);</span>
<span class="nc" id="L63">    }</span>

    public OODataModel getDataModel() {
<span class="nc" id="L66">        return backend.dataModel;</span>
    }

    public Optional&lt;String&gt; healthReport(XTextDocument doc)
        throws
        NoDocumentException {
<span class="nc" id="L72">        return backend.healthReport(doc);</span>
    }

    private static Map&lt;CitationGroupId, CitationGroup&gt;
    readCitationGroupsFromDocument(Backend52 backend,
                                   XTextDocument doc,
                                   List&lt;String&gt; citationGroupNames)
        throws
        WrappedTargetException,
        NoDocumentException {

<span class="nc" id="L83">        Map&lt;CitationGroupId, CitationGroup&gt; citationGroups = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">        for (String name : citationGroupNames) {</span>
<span class="nc" id="L85">            CitationGroup group = backend.readCitationGroupFromDocumentOrThrow(doc, name);</span>
<span class="nc" id="L86">            citationGroups.put(group.groupId, group);</span>
<span class="nc" id="L87">        }</span>
<span class="nc" id="L88">        return citationGroups;</span>
    }

    /**
     * Creates a list of {@code RangeSortable&lt;CitationGroup&gt;} values for our {@code CitationGroup}
     * values. Originally designed to be passed to {@code visualSort}.
     *
     * The elements of the returned list are actually of type {@code RangeSortEntry&lt;CitationGroup&gt;}.
     *
     * The result is sorted within {@code XTextRange.getText()} partitions of the citation groups
     * according to their {@code XTextRange} (before mapping to footnote marks).
     *
     * In the result, RangeSortable.getIndexInPosition() contains unique indexes within the original
     * partition (not after mapFootnotesToFootnoteMarks).
     *
     * @param mapFootnotesToFootnoteMarks If true, replace ranges in footnotes with the range of the
     *        corresponding footnote mark. This is used for numbering the citations.
     *
     */
    private List&lt;RangeSortable&lt;CitationGroup&gt;&gt;
    createVisualSortInput(XTextDocument doc, boolean mapFootnotesToFootnoteMarks)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L113">        List&lt;RangeSortEntry&lt;CitationGroup&gt;&gt; sortables = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">        for (CitationGroup group : citationGroups.getCitationGroupsUnordered()) {</span>
<span class="nc" id="L115">            XTextRange range = (this</span>
<span class="nc" id="L116">                                .getMarkRange(doc, group)</span>
<span class="nc" id="L117">                                .orElseThrow(IllegalStateException::new));</span>
<span class="nc" id="L118">            sortables.add(new RangeSortEntry&lt;&gt;(range, 0, group));</span>
<span class="nc" id="L119">        }</span>

        /*
         *  At this point we are almost ready to return sortables.
         *
         *  But we may want to number citations in a footnote as if it appeared where the footnote
         *  mark is.
         *
         *  The following code replaces ranges within footnotes with the range for the corresponding
         *  footnote mark.
         *
         *  This brings further ambiguity if we have multiple citation groups within the same
         *  footnote: for the comparison they become indistinguishable. Numbering between them is
         *  not controlled. Also combineCiteMarkers will see them in the wrong order (if we use this
         *  comparison), and will not be able to merge. To avoid these, we sort textually within
         *  each .getText() partition and add indexInPosition accordingly.
         *
         */

        // Sort within partitions
<span class="nc" id="L139">        RangeSort.RangePartitions&lt;RangeSortEntry&lt;CitationGroup&gt;&gt; partitions =</span>
<span class="nc" id="L140">            RangeSort.partitionAndSortRanges(sortables);</span>

        // build final list
<span class="nc" id="L143">        List&lt;RangeSortEntry&lt;CitationGroup&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">        for (List&lt;RangeSortEntry&lt;CitationGroup&gt;&gt; partition : partitions.getPartitions()) {</span>

<span class="nc" id="L146">            int indexInPartition = 0;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            for (RangeSortEntry&lt;CitationGroup&gt; sortable : partition) {</span>
<span class="nc" id="L148">                sortable.setIndexInPosition(indexInPartition++);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">                if (mapFootnotesToFootnoteMarks) {</span>
<span class="nc" id="L150">                    Optional&lt;XTextRange&gt; footnoteMarkRange =</span>
<span class="nc" id="L151">                        UnoTextRange.getFootnoteMarkRange(sortable.getRange());</span>
                    // Adjust range if we are inside a footnote:
<span class="nc bnc" id="L153" title="All 2 branches missed.">                    if (footnoteMarkRange.isPresent()) {</span>
<span class="nc" id="L154">                        sortable.setRange(footnoteMarkRange.get());</span>
                    }
                }
<span class="nc" id="L157">                result.add(sortable);</span>
<span class="nc" id="L158">            }</span>
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">        return result.stream().map(e -&gt; e).collect(Collectors.toList());</span>
    }

    /**
     *  @param mapFootnotesToFootnoteMarks If true, sort reference marks in footnotes as if they
     *         appeared at the corresponding footnote mark.
     *
     *  @return citation groups sorted by their visual positions.
     *
     *  Limitation: for two column layout visual (top-down, left-right) order does not match the
     *        expected (textual) order.
     *
     */
    private List&lt;CitationGroup&gt; getVisuallySortedCitationGroups(XTextDocument doc,
                                                                boolean mapFootnotesToFootnoteMarks,
                                                                FunctionalTextViewCursor fcursor)
        throws
        WrappedTargetException,
        NoDocumentException {

<span class="nc" id="L180">        List&lt;RangeSortable&lt;CitationGroup&gt;&gt; sortables = createVisualSortInput(doc, mapFootnotesToFootnoteMarks);</span>

<span class="nc" id="L182">        List&lt;RangeSortable&lt;CitationGroup&gt;&gt; sorted = RangeSortVisual.visualSort(sortables, doc, fcursor);</span>

<span class="nc" id="L184">        return (sorted.stream()</span>
<span class="nc" id="L185">                .map(RangeSortable&lt;CitationGroup&gt;::getContent)</span>
<span class="nc" id="L186">                .collect(Collectors.toList()));</span>
    }

    /**
     * Return citation groups in visual order within (but not across) XText partitions.
     *
     * This is (1) sufficient for combineCiteMarkers which looks for consecutive XTextRanges within
     * each XText, (2) not confused by multicolumn layout or multipage display.
     */
    public List&lt;CitationGroup&gt;
    getCitationGroupsSortedWithinPartitions(XTextDocument doc, boolean mapFootnotesToFootnoteMarks)
        throws
        NoDocumentException,
        WrappedTargetException {
        // This is like getVisuallySortedCitationGroups,
        // but we skip the visualSort part.
<span class="nc" id="L202">        List&lt;RangeSortable&lt;CitationGroup&gt;&gt; sortables =</span>
<span class="nc" id="L203">            createVisualSortInput(doc, mapFootnotesToFootnoteMarks);</span>

<span class="nc" id="L205">        return (sortables.stream().map(e -&gt; e.getContent()).collect(Collectors.toList()));</span>
    }

    /**
     *  Create a citation group for the given citation keys, at the end of position.
     *
     *  On return {@code position} is collapsed, and is after the inserted space, or at the end of
     *  the reference mark.
     *
     * @param citationKeys In storage order
     * @param pageInfos In storage order
     * @param citationType
     * @param position Collapsed to its end.
     * @param insertSpaceAfter If true, we insert a space after the mark, that carries on format of
     *                         characters from the original position.
     */
    public CitationGroup createCitationGroup(XTextDocument doc,
                                             List&lt;String&gt; citationKeys,
                                             List&lt;Optional&lt;OOText&gt;&gt; pageInfos,
                                             CitationType citationType,
                                             XTextCursor position,
                                             boolean insertSpaceAfter)
        throws
        CreationException,
        NoDocumentException,
        WrappedTargetException,
        NotRemoveableException,
        PropertyVetoException,
        IllegalTypeException {

<span class="nc" id="L235">        Objects.requireNonNull(pageInfos);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">        if (pageInfos.size() != citationKeys.size()) {</span>
<span class="nc" id="L237">            throw new IllegalArgumentException(&quot;pageInfos.size != citationKeys.size&quot;);</span>
        }
<span class="nc" id="L239">        CitationGroup group = backend.createCitationGroup(doc,</span>
                                                          citationKeys,
                                                          pageInfos,
                                                          citationType,
                                                          position,
                                                          insertSpaceAfter);

<span class="nc" id="L246">        this.citationGroups.afterCreateCitationGroup(group);</span>
<span class="nc" id="L247">        return group;</span>
    }

    /**
     * Remove {@code group} both from the document and notify {@code citationGroups}
     */
    public void removeCitationGroup(CitationGroup group, XTextDocument doc)
        throws
        WrappedTargetException,
        NoDocumentException,
        NotRemoveableException {

<span class="nc" id="L259">        backend.removeCitationGroup(group, doc);</span>
<span class="nc" id="L260">        this.citationGroups.afterRemoveCitationGroup(group);</span>
<span class="nc" id="L261">    }</span>

    public void removeCitationGroups(List&lt;CitationGroup&gt; cgs, XTextDocument doc)
        throws
        WrappedTargetException,
        NoDocumentException,
        NotRemoveableException {

<span class="nc bnc" id="L269" title="All 2 branches missed.">        for (CitationGroup group : cgs) {</span>
<span class="nc" id="L270">            removeCitationGroup(group, doc);</span>
<span class="nc" id="L271">        }</span>
<span class="nc" id="L272">    }</span>

    /**
     * ranges controlled by citation groups should not overlap with each other.
     *
     * @return Optional.empty() if the reference mark is missing.
     *
     */
    public Optional&lt;XTextRange&gt; getMarkRange(XTextDocument doc, CitationGroup group)
        throws
        NoDocumentException,
        WrappedTargetException {
<span class="nc" id="L284">        return backend.getMarkRange(group, doc);</span>
    }

    public XTextCursor getFillCursorForCitationGroup(XTextDocument doc, CitationGroup group)
        throws
        NoDocumentException,
        WrappedTargetException,
        CreationException {
<span class="nc" id="L292">        return backend.getFillCursorForCitationGroup(group, doc);</span>
    }

    /**
     * Remove brackets added by getFillCursorForCitationGroup.
     */
    public void cleanFillCursorForCitationGroup(XTextDocument doc, CitationGroup group)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L303">        backend.cleanFillCursorForCitationGroup(group, doc);</span>
<span class="nc" id="L304">    }</span>

    /**
     * @return A RangeForOverlapCheck for each citation group.
     *
     *  result.size() == nRefMarks
     */
    public List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; citationRanges(XTextDocument doc)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L316">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; result =</span>
<span class="nc" id="L317">            new ArrayList&lt;&gt;(citationGroups.numberOfCitationGroups());</span>

<span class="nc bnc" id="L319" title="All 2 branches missed.">        for (CitationGroup group : citationGroups.getCitationGroupsUnordered()) {</span>
<span class="nc" id="L320">            XTextRange range = this.getMarkRange(doc, group).orElseThrow(IllegalStateException::new);</span>
<span class="nc" id="L321">            String description = group.groupId.citationGroupIdAsString();</span>
<span class="nc" id="L322">            result.add(new RangeForOverlapCheck&lt;&gt;(range,</span>
                                                  group.groupId,
                                                  RangeForOverlapCheck.REFERENCE_MARK_KIND,
                                                  description));
<span class="nc" id="L326">        }</span>
<span class="nc" id="L327">        return result;</span>
    }

    public List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; bibliographyRanges(XTextDocument doc)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L335">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L337">        Optional&lt;XTextRange&gt; range = UpdateBibliography.getBibliographyRange(doc);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        if (range.isPresent()) {</span>
<span class="nc" id="L339">            String description = &quot;bibliography&quot;;</span>
<span class="nc" id="L340">            result.add(new RangeForOverlapCheck&lt;&gt;(range.get(),</span>
                                                  new CitationGroupId(&quot;bibliography&quot;),
                                                  RangeForOverlapCheck.BIBLIOGRAPHY_MARK_KIND,
                                                  description));
        }
<span class="nc" id="L345">        return result;</span>
    }

    public List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; viewCursorRanges(XTextDocument doc) {

<span class="nc" id="L350">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; result = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L352">        Optional&lt;XTextRange&gt; range = UnoCursor.getViewCursor(doc).map(e -&gt; e);</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">        if (range.isPresent()) {</span>
<span class="nc" id="L354">            String description = &quot;cursor&quot;;</span>
<span class="nc" id="L355">            result.add(new RangeForOverlapCheck&lt;&gt;(range.get(),</span>
                                                  new CitationGroupId(&quot;cursor&quot;),
                                                  RangeForOverlapCheck.CURSOR_MARK_KIND,
                                                  description));
        }
<span class="nc" id="L360">        return result;</span>
    }

    /**
     * @return A range for each footnote mark where the footnote contains at least one citation group.
     *
     *  Purpose: We do not want markers of footnotes containing reference marks to overlap with
     *  reference marks. Overwriting these footnote marks might kill our reference marks in the
     *  footnote.
     *
     *  Note: Here we directly communicate to the document, not through the backend. This is because
     *        mapping ranges to footnote marks does not depend on how do we mark or structure those
     *        ranges.
     */
    public List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt;
    footnoteMarkRanges(XTextDocument doc, List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; citationRanges) {

        // We partition by XText and use a single range from
        // each partition to get at the corresponding footnotemark range.

<span class="nc" id="L380">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L381">        RangeSort.RangePartitions&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; partitions =</span>
<span class="nc" id="L382">            RangeSort.partitionRanges(citationRanges);</span>

        // Each partition corresponds to an XText, and each footnote has a single XText.
        // (This latter ignores the possibility of XTextContents inserted into footnotes.)
        // Also: different footnotes cannot share a footnotemark range, we are not creating duplicates.
<span class="nc bnc" id="L387" title="All 2 branches missed.">        for (List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; partition : partitions.getPartitions()) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">            if (partition.isEmpty()) {</span>
<span class="nc" id="L389">                continue;</span>
            }
<span class="nc" id="L391">            RangeForOverlapCheck&lt;CitationGroupId&gt; citationRange = partition.get(0);</span>

<span class="nc" id="L393">            Optional&lt;XTextRange&gt; footnoteMarkRange = UnoTextRange.getFootnoteMarkRange(citationRange.range);</span>

<span class="nc bnc" id="L395" title="All 2 branches missed.">            if (footnoteMarkRange.isEmpty()) {</span>
                // not in footnote
<span class="nc" id="L397">                continue;</span>
            }

<span class="nc" id="L400">            result.add(new RangeForOverlapCheck&lt;&gt;(footnoteMarkRange.get(),</span>
                                                  citationRange.idWithinKind,
                                                  RangeForOverlapCheck.FOOTNOTE_MARK_KIND,
<span class="nc" id="L403">                                                  &quot;FootnoteMark for &quot; + citationRange.format()));</span>
<span class="nc" id="L404">        }</span>
<span class="nc" id="L405">        return result;</span>
    }

    static String rangeOverlapsToMessage(List&lt;RangeOverlap&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt;&gt; overlaps) {

<span class="nc bnc" id="L410" title="All 2 branches missed.">        if (overlaps.isEmpty()) {</span>
<span class="nc" id="L411">            return &quot;(*no overlaps*)&quot;;</span>
        }

<span class="nc" id="L414">        StringBuilder msg = new StringBuilder();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        for (RangeOverlap&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; overlap : overlaps) {</span>
<span class="nc" id="L416">            String listOfRanges = (overlap.valuesForOverlappingRanges.stream()</span>
<span class="nc" id="L417">                                   .map(v -&gt; String.format(&quot;'%s'&quot;, v.format()))</span>
<span class="nc" id="L418">                                   .collect(Collectors.joining(&quot;, &quot;)));</span>
<span class="nc" id="L419">            msg.append(</span>
<span class="nc bnc" id="L420" title="All 4 branches missed.">                switch (overlap.kind) {</span>
<span class="nc" id="L421">                    case EQUAL_RANGE -&gt; Localization.lang(&quot;Found identical ranges&quot;);</span>
<span class="nc" id="L422">                    case OVERLAP -&gt; Localization.lang(&quot;Found overlapping ranges&quot;);</span>
<span class="nc" id="L423">                    case TOUCH -&gt; Localization.lang(&quot;Found touching ranges&quot;);</span>
                });
<span class="nc" id="L425">            msg.append(&quot;: &quot;);</span>
<span class="nc" id="L426">            msg.append(listOfRanges);</span>
<span class="nc" id="L427">            msg.append(&quot;\n&quot;);</span>
<span class="nc" id="L428">        }</span>
<span class="nc" id="L429">        return msg.toString();</span>
    }

    /**
     * Check for any overlap between userRanges and protected ranges.
     *
     * Assume userRanges is small (usually 1 elements for checking the cursor)
     *
     * Returns on first problem found.
     */
    public OOVoidResult&lt;JabRefException&gt;
    checkRangeOverlapsWithCursor(XTextDocument doc,
                                 List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; userRanges,
                                 boolean requireSeparation)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L447">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; citationRanges = citationRanges(doc);</span>
<span class="nc" id="L448">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>

        // ranges.addAll(userRanges);
<span class="nc" id="L451">        ranges.addAll(bibliographyRanges(doc));</span>
<span class="nc" id="L452">        ranges.addAll(citationRanges);</span>
<span class="nc" id="L453">        ranges.addAll(footnoteMarkRanges(doc, citationRanges));</span>

<span class="nc" id="L455">        List&lt;RangeOverlap&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt;&gt; overlaps =</span>
<span class="nc" id="L456">            RangeOverlapBetween.findFirst(doc,</span>
                                          userRanges,
                                          ranges,
                                          requireSeparation);

<span class="nc bnc" id="L461" title="All 2 branches missed.">        if (overlaps.isEmpty()) {</span>
<span class="nc" id="L462">            return OOVoidResult.ok();</span>
        }
<span class="nc" id="L464">        return OOVoidResult.error(new JabRefException(&quot;Found overlapping or touching ranges&quot;,</span>
<span class="nc" id="L465">                                                      rangeOverlapsToMessage(overlaps)));</span>
    }

    /**
     * @param requireSeparation Report range pairs that only share a boundary.
     * @param reportAtMost Limit number of overlaps reported (0 for no limit)
     *
     */
    public OOVoidResult&lt;JabRefException&gt; checkRangeOverlaps(XTextDocument doc,
                                                            List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; userRanges,
                                                            boolean requireSeparation,
                                                            int reportAtMost)
        throws
        NoDocumentException,
        WrappedTargetException {

<span class="nc" id="L481">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; citationRanges = citationRanges(doc);</span>
<span class="nc" id="L482">        List&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt; ranges = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L483">        ranges.addAll(userRanges);</span>
<span class="nc" id="L484">        ranges.addAll(bibliographyRanges(doc));</span>
<span class="nc" id="L485">        ranges.addAll(citationRanges);</span>
<span class="nc" id="L486">        ranges.addAll(footnoteMarkRanges(doc, citationRanges));</span>

<span class="nc" id="L488">        List&lt;RangeOverlap&lt;RangeForOverlapCheck&lt;CitationGroupId&gt;&gt;&gt; overlaps =</span>
<span class="nc" id="L489">            RangeOverlapWithin.findOverlappingRanges(doc, ranges, requireSeparation, reportAtMost);</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">        if (overlaps.isEmpty()) {</span>
<span class="nc" id="L492">            return OOVoidResult.ok();</span>
        }
<span class="nc" id="L494">        return OOVoidResult.error(new JabRefException(&quot;Found overlapping or touching ranges&quot;,</span>
<span class="nc" id="L495">                                                      rangeOverlapsToMessage(overlaps)));</span>
    }

    /**
     * GUI: Get a list of CitationEntry objects corresponding to citations
     * in the document.
     *
     * Called from: ManageCitationsDialogViewModel constructor.
     *
     * @return A list with entries corresponding to citations in the text, in arbitrary order (same
     *         order as from getJabRefReferenceMarkNames).
     *
     *               Note: visual or alphabetic order could be more manageable for the user. We
     *               could provide these here, but switching between them needs change on GUI
     *               (adding a toggle or selector).
     *
     *               Note: CitationEntry implements Comparable, where compareTo() and equals() are
     *                     based on refMarkName.  The order used in the &quot;Manage citations&quot; dialog
     *                     does not seem to use that.
     *
     *                     The 1st is labeled &quot;Citation&quot; (show citation in bold, and some context
     *                     around it).
     *
     *                     The columns can be sorted by clicking on the column title.  For the
     *                     &quot;Citation&quot; column, the sorting is based on the content, (the context
     *                     before the citation), not on the citation itself.
     *
     *                     In the &quot;Extra information ...&quot; column some visual indication of the
     *                     editable part could be helpful.
     *
     *         Wish: selecting an entry (or a button in the line) in the GUI could move the cursor
     *               in the document to the entry.
     */
    public List&lt;CitationEntry&gt; getCitationEntries(XTextDocument doc)
        throws
        WrappedTargetException,
        NoDocumentException {
<span class="nc" id="L532">        return this.backend.getCitationEntries(doc, citationGroups);</span>
    }

    public void applyCitationEntries(XTextDocument doc, List&lt;CitationEntry&gt; citationEntries)
        throws
        PropertyVetoException,
        IllegalTypeException,
        IllegalArgumentException,
        WrappedTargetException {
<span class="nc" id="L541">        this.backend.applyCitationEntries(doc, citationEntries);</span>
<span class="nc" id="L542">    }</span>

    public void imposeGlobalOrder(XTextDocument doc, FunctionalTextViewCursor fcursor)
        throws
        WrappedTargetException,
        NoDocumentException {

<span class="nc" id="L549">        boolean mapFootnotesToFootnoteMarks = true;</span>
<span class="nc" id="L550">        List&lt;CitationGroup&gt; sortedCitationGroups =</span>
<span class="nc" id="L551">            getVisuallySortedCitationGroups(doc, mapFootnotesToFootnoteMarks, fcursor);</span>
<span class="nc" id="L552">        List&lt;CitationGroupId&gt; sortedCitationGroupIds = OOListUtil.map(sortedCitationGroups, group -&gt; group.groupId);</span>
<span class="nc" id="L553">        citationGroups.setGlobalOrder(sortedCitationGroupIds);</span>
<span class="nc" id="L554">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>