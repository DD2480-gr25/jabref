<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BindingsHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.gui.util</a> &gt; <span class="el_source">BindingsHelper.java</span></div><h1>BindingsHelper.java</h1><pre class="source lang-java linenums">package org.jabref.gui.util;

import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Function;

import javafx.beans.binding.BooleanBinding;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.binding.StringBinding;
import javafx.beans.property.ListProperty;
import javafx.beans.property.Property;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ListChangeListener;
import javafx.collections.MapChangeListener;
import javafx.collections.ObservableList;
import javafx.collections.ObservableMap;
import javafx.css.PseudoClass;
import javafx.scene.Node;

import com.tobiasdiez.easybind.EasyBind;
import com.tobiasdiez.easybind.PreboundBinding;
import com.tobiasdiez.easybind.Subscription;

/**
 * Helper methods for javafx binding. Some methods are taken from https://bugs.openjdk.java.net/browse/JDK-8134679
 */
public class BindingsHelper {

    private BindingsHelper() {
    }

    public static Subscription includePseudoClassWhen(Node node, PseudoClass pseudoClass, ObservableValue&lt;? extends Boolean&gt; condition) {
<span class="nc" id="L36">        Consumer&lt;Boolean&gt; changePseudoClass = value -&gt; node.pseudoClassStateChanged(pseudoClass, value);</span>
<span class="nc" id="L37">        Subscription subscription = EasyBind.subscribe(condition, changePseudoClass);</span>

        // Put the pseudo class there depending on the current value
<span class="nc" id="L40">        changePseudoClass.accept(condition.getValue());</span>
<span class="nc" id="L41">        return subscription;</span>
    }

    public static &lt;T, U&gt; ObservableList&lt;U&gt; map(ObservableValue&lt;T&gt; source, Function&lt;T, List&lt;U&gt;&gt; mapper) {
<span class="nc" id="L45">        PreboundBinding&lt;List&lt;U&gt;&gt; binding = new PreboundBinding&lt;&gt;(source) {</span>

            @Override
            protected List&lt;U&gt; computeValue() {
<span class="nc" id="L49">                return mapper.apply(source.getValue());</span>
            }
        };

<span class="nc" id="L53">        ObservableList&lt;U&gt; list = FXCollections.observableArrayList();</span>
<span class="nc" id="L54">        binding.addListener((observable, oldValue, newValue) -&gt; list.setAll(newValue));</span>
<span class="nc" id="L55">        return list;</span>
    }

    /**
     * Binds propertyA bidirectional to propertyB using the provided map functions to convert between them.
     */
    public static &lt;A, B&gt; void bindBidirectional(Property&lt;A&gt; propertyA, Property&lt;B&gt; propertyB, Function&lt;A, B&gt; mapAtoB, Function&lt;B, A&gt; mapBtoA) {
<span class="fc" id="L62">        Consumer&lt;B&gt; updateA = newValueB -&gt; propertyA.setValue(mapBtoA.apply(newValueB));</span>
<span class="pc" id="L63">        Consumer&lt;A&gt; updateB = newValueA -&gt; propertyB.setValue(mapAtoB.apply(newValueA));</span>
<span class="fc" id="L64">        bindBidirectional(propertyA, propertyB, updateA, updateB);</span>
<span class="fc" id="L65">    }</span>

    /**
     * Binds propertyA bidirectional to propertyB while using updateB to update propertyB when propertyA changed.
     */
    public static &lt;A&gt; void bindBidirectional(Property&lt;A&gt; propertyA, ObservableValue&lt;A&gt; propertyB, Consumer&lt;A&gt; updateB) {
<span class="nc" id="L71">        bindBidirectional(propertyA, propertyB, propertyA::setValue, updateB);</span>
<span class="nc" id="L72">    }</span>

    /**
     * Binds propertyA bidirectional to propertyB using updateB to update propertyB when propertyA changed and similar for updateA.
     */
    public static &lt;A, B&gt; void bindBidirectional(ObservableValue&lt;A&gt; propertyA, ObservableValue&lt;B&gt; propertyB, Consumer&lt;B&gt; updateA, Consumer&lt;A&gt; updateB) {
<span class="fc" id="L78">        final BidirectionalBinding&lt;A, B&gt; binding = new BidirectionalBinding&lt;&gt;(propertyA, propertyB, updateA, updateB);</span>

        // use updateB as initial source
<span class="fc" id="L81">        updateA.accept(propertyB.getValue());</span>

<span class="fc" id="L83">        propertyA.addListener(binding.getChangeListenerA());</span>
<span class="fc" id="L84">        propertyB.addListener(binding.getChangeListenerB());</span>
<span class="fc" id="L85">    }</span>

    public static &lt;A, B&gt; void bindContentBidirectional(ObservableList&lt;A&gt; propertyA, ListProperty&lt;B&gt; propertyB, Consumer&lt;ObservableList&lt;B&gt;&gt; updateA, Consumer&lt;List&lt;A&gt;&gt; updateB) {
<span class="nc" id="L88">        bindContentBidirectional(</span>
                propertyA,
                (ObservableValue&lt;ObservableList&lt;B&gt;&gt;) propertyB,
                updateA,
                updateB);
<span class="nc" id="L93">    }</span>

    public static &lt;A, B&gt; void bindContentBidirectional(ObservableList&lt;A&gt; propertyA, ObservableValue&lt;B&gt; propertyB, Consumer&lt;B&gt; updateA, Consumer&lt;List&lt;A&gt;&gt; updateB) {
<span class="nc" id="L96">        final BidirectionalListBinding&lt;A, B&gt; binding = new BidirectionalListBinding&lt;&gt;(propertyA, propertyB, updateA, updateB);</span>

        // use property as initial source
<span class="nc" id="L99">        updateA.accept(propertyB.getValue());</span>

<span class="nc" id="L101">        propertyA.addListener(binding);</span>
<span class="nc" id="L102">        propertyB.addListener(binding);</span>
<span class="nc" id="L103">    }</span>

    public static &lt;A, B&gt; void bindContentBidirectional(ListProperty&lt;A&gt; listProperty, Property&lt;B&gt; property, Function&lt;List&lt;A&gt;, B&gt; mapToB, Function&lt;B, List&lt;A&gt;&gt; mapToList) {
<span class="nc" id="L106">        Consumer&lt;B&gt; updateList = newValueB -&gt; listProperty.setAll(mapToList.apply(newValueB));</span>
<span class="nc" id="L107">        Consumer&lt;List&lt;A&gt;&gt; updateB = newValueList -&gt; property.setValue(mapToB.apply(newValueList));</span>

<span class="nc" id="L109">        bindContentBidirectional(</span>
                listProperty,
                property,
                updateList,
                updateB);
<span class="nc" id="L114">    }</span>

    public static &lt;A, V, B&gt; void bindContentBidirectional(ObservableMap&lt;A, V&gt; propertyA, ObservableValue&lt;B&gt; propertyB, Consumer&lt;B&gt; updateA, Consumer&lt;Map&lt;A, V&gt;&gt; updateB) {
<span class="nc" id="L117">        final BidirectionalMapBinding&lt;A, V, B&gt; binding = new BidirectionalMapBinding&lt;&gt;(propertyA, propertyB, updateA, updateB);</span>

        // use list as initial source
<span class="nc" id="L120">        updateB.accept(propertyA);</span>

<span class="nc" id="L122">        propertyA.addListener(binding);</span>
<span class="nc" id="L123">        propertyB.addListener(binding);</span>
<span class="nc" id="L124">    }</span>

    public static &lt;A, V, B&gt; void bindContentBidirectional(ObservableMap&lt;A, V&gt; propertyA, Property&lt;B&gt; propertyB, Consumer&lt;B&gt; updateA, Function&lt;Map&lt;A, V&gt;, B&gt; mapToB) {
<span class="nc" id="L127">        Consumer&lt;Map&lt;A, V&gt;&gt; updateB = newValueList -&gt; propertyB.setValue(mapToB.apply(newValueList));</span>
<span class="nc" id="L128">        bindContentBidirectional(</span>
                propertyA,
                propertyB,
                updateA,
                updateB);
<span class="nc" id="L133">    }</span>

    public static &lt;T&gt; ObservableValue&lt;T&gt; constantOf(T value) {
<span class="nc" id="L136">        return new ObjectBinding&lt;&gt;() {</span>

            @Override
            protected T computeValue() {
<span class="nc" id="L140">                return value;</span>
            }
        };
    }

    public static ObservableValue&lt;Boolean&gt; constantOf(boolean value) {
<span class="nc" id="L146">        return new BooleanBinding() {</span>

            @Override
            protected boolean computeValue() {
<span class="nc" id="L150">                return value;</span>
            }
        };
    }

    public static ObservableValue&lt;? extends String&gt; emptyString() {
<span class="nc" id="L156">        return new StringBinding() {</span>

            @Override
            protected String computeValue() {
<span class="nc" id="L160">                return &quot;&quot;;</span>
            }
        };
    }

    /**
     * Returns a wrapper around the given list that posts changes on the JavaFX thread.
     */
    public static &lt;T&gt; ObservableList&lt;T&gt; forUI(ObservableList&lt;T&gt; list) {
<span class="nc" id="L169">        return new UiThreadList&lt;&gt;(list);</span>
    }

    public static &lt;T&gt; ObservableValue&lt;T&gt; ifThenElse(ObservableValue&lt;Boolean&gt; condition, T value, T other) {
<span class="nc" id="L173">        return EasyBind.map(condition, conditionValue -&gt; {</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">            if (conditionValue) {</span>
<span class="nc" id="L175">                return value;</span>
            } else {
<span class="nc" id="L177">                return other;</span>
            }
        });
    }

    /**
     * Invokes {@code subscriber} for the every new value of {@code observable}, but not for the current value.
     *
     * @param observable observable value to subscribe to
     * @param subscriber action to invoke for values of {@code observable}.
     * @return a subscription that can be used to stop invoking subscriber for any further {@code observable} changes.
     * @apiNote {@link EasyBind#subscribe(ObservableValue, Consumer)} is similar but also invokes the {@code subscriber} for the current value
     */
    public static &lt;T&gt; Subscription subscribeFuture(ObservableValue&lt;T&gt; observable, Consumer&lt;? super T&gt; subscriber) {
<span class="nc" id="L191">        ChangeListener&lt;? super T&gt; listener = (obs, oldValue, newValue) -&gt; subscriber.accept(newValue);</span>
<span class="nc" id="L192">        observable.addListener(listener);</span>
<span class="nc" id="L193">        return () -&gt; observable.removeListener(listener);</span>
    }

    private static class BidirectionalBinding&lt;A, B&gt; {

        private final ObservableValue&lt;A&gt; propertyA;
        private final Consumer&lt;B&gt; updateA;
        private final Consumer&lt;A&gt; updateB;
<span class="fc" id="L201">        private boolean updating = false;</span>

<span class="fc" id="L203">        public BidirectionalBinding(ObservableValue&lt;A&gt; propertyA, ObservableValue&lt;B&gt; propertyB, Consumer&lt;B&gt; updateA, Consumer&lt;A&gt; updateB) {</span>
<span class="fc" id="L204">            this.propertyA = propertyA;</span>
<span class="fc" id="L205">            this.updateA = updateA;</span>
<span class="fc" id="L206">            this.updateB = updateB;</span>
<span class="fc" id="L207">        }</span>

        public ChangeListener&lt;? super A&gt; getChangeListenerA() {
<span class="fc" id="L210">            return this::changedA;</span>
        }

        public ChangeListener&lt;? super B&gt; getChangeListenerB() {
<span class="fc" id="L214">            return this::changedB;</span>
        }

        public void changedA(ObservableValue&lt;? extends A&gt; observable, A oldValue, A newValue) {
<span class="nc" id="L218">            updateLocked(updateB, oldValue, newValue);</span>
<span class="nc" id="L219">        }</span>

        public void changedB(ObservableValue&lt;? extends B&gt; observable, B oldValue, B newValue) {
<span class="nc" id="L222">            updateLocked(updateA, oldValue, newValue);</span>
<span class="nc" id="L223">        }</span>

        private &lt;T&gt; void updateLocked(Consumer&lt;T&gt; update, T oldValue, T newValue) {
<span class="nc bnc" id="L226" title="All 2 branches missed.">            if (!updating) {</span>
                try {
<span class="nc" id="L228">                    updating = true;</span>
<span class="nc" id="L229">                    update.accept(newValue);</span>
                } finally {
<span class="nc" id="L231">                    updating = false;</span>
                }
            }
<span class="nc" id="L234">        }</span>
    }

    private static class BidirectionalListBinding&lt;A, B&gt; implements ListChangeListener&lt;A&gt;, ChangeListener&lt;B&gt; {

        private final ObservableList&lt;A&gt; listProperty;
        private final ObservableValue&lt;B&gt; property;
        private final Consumer&lt;B&gt; updateA;
        private final Consumer&lt;List&lt;A&gt;&gt; updateB;
<span class="nc" id="L243">        private boolean updating = false;</span>

<span class="nc" id="L245">        public BidirectionalListBinding(ObservableList&lt;A&gt; listProperty, ObservableValue&lt;B&gt; property, Consumer&lt;B&gt; updateA, Consumer&lt;List&lt;A&gt;&gt; updateB) {</span>
<span class="nc" id="L246">            this.listProperty = listProperty;</span>
<span class="nc" id="L247">            this.property = property;</span>
<span class="nc" id="L248">            this.updateA = updateA;</span>
<span class="nc" id="L249">            this.updateB = updateB;</span>
<span class="nc" id="L250">        }</span>

        @Override
        public void changed(ObservableValue&lt;? extends B&gt; observable, B oldValue, B newValue) {
<span class="nc bnc" id="L254" title="All 2 branches missed.">            if (!updating) {</span>
                try {
<span class="nc" id="L256">                    updating = true;</span>
<span class="nc" id="L257">                    updateA.accept(newValue);</span>
                } finally {
<span class="nc" id="L259">                    updating = false;</span>
                }
            }
<span class="nc" id="L262">        }</span>

        @Override
        public void onChanged(Change&lt;? extends A&gt; c) {
<span class="nc bnc" id="L266" title="All 2 branches missed.">            if (!updating) {</span>
                try {
<span class="nc" id="L268">                    updating = true;</span>
<span class="nc" id="L269">                    updateB.accept(listProperty);</span>
                } finally {
<span class="nc" id="L271">                    updating = false;</span>
                }
            }
<span class="nc" id="L274">        }</span>
    }

    private static class BidirectionalMapBinding&lt;A, V, B&gt; implements MapChangeListener&lt;A, V&gt;, ChangeListener&lt;B&gt; {

        private final ObservableMap&lt;A, V&gt; mapProperty;
        private final ObservableValue&lt;B&gt; property;
        private final Consumer&lt;B&gt; updateA;
        private final Consumer&lt;Map&lt;A, V&gt;&gt; updateB;
<span class="nc" id="L283">        private boolean updating = false;</span>

<span class="nc" id="L285">        public BidirectionalMapBinding(ObservableMap&lt;A, V&gt; mapProperty, ObservableValue&lt;B&gt; property, Consumer&lt;B&gt; updateA, Consumer&lt;Map&lt;A, V&gt;&gt; updateB) {</span>
<span class="nc" id="L286">            this.mapProperty = mapProperty;</span>
<span class="nc" id="L287">            this.property = property;</span>
<span class="nc" id="L288">            this.updateA = updateA;</span>
<span class="nc" id="L289">            this.updateB = updateB;</span>
<span class="nc" id="L290">        }</span>

        @Override
        public void changed(ObservableValue&lt;? extends B&gt; observable, B oldValue, B newValue) {
<span class="nc bnc" id="L294" title="All 2 branches missed.">            if (!updating) {</span>
                try {
<span class="nc" id="L296">                    updating = true;</span>
<span class="nc" id="L297">                    updateA.accept(newValue);</span>
                } finally {
<span class="nc" id="L299">                    updating = false;</span>
                }
            }
<span class="nc" id="L302">        }</span>

        @Override
        public void onChanged(Change&lt;? extends A, ? extends V&gt; c) {
<span class="nc bnc" id="L306" title="All 2 branches missed.">            if (!updating) {</span>
                try {
<span class="nc" id="L308">                    updating = true;</span>
<span class="nc" id="L309">                    updateB.accept(mapProperty);</span>
                } finally {
<span class="nc" id="L311">                    updating = false;</span>
                }
            }
<span class="nc" id="L314">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>