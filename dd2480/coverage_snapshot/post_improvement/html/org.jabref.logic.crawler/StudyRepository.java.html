<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StudyRepository.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.crawler</a> &gt; <span class="el_source">StudyRepository.java</span></div><h1>StudyRepository.java</h1><pre class="source lang-java linenums">package org.jabref.logic.crawler;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.UnsupportedCharsetException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.temporal.ChronoUnit;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.jabref.logic.citationkeypattern.CitationKeyGenerator;
import org.jabref.logic.database.DatabaseMerger;
import org.jabref.logic.exporter.BibWriter;
import org.jabref.logic.exporter.BibtexDatabaseWriter;
import org.jabref.logic.exporter.SaveException;
import org.jabref.logic.exporter.SavePreferences;
import org.jabref.logic.git.SlrGitHandler;
import org.jabref.logic.importer.ImportFormatPreferences;
import org.jabref.logic.importer.OpenDatabase;
import org.jabref.logic.importer.ParseException;
import org.jabref.logic.importer.SearchBasedFetcher;
import org.jabref.logic.l10n.Localization;
import org.jabref.logic.util.OS;
import org.jabref.model.database.BibDatabase;
import org.jabref.model.database.BibDatabaseContext;
import org.jabref.model.entry.BibEntryTypesManager;
import org.jabref.model.study.FetchResult;
import org.jabref.model.study.QueryResult;
import org.jabref.model.study.Study;
import org.jabref.model.study.StudyDatabase;
import org.jabref.model.study.StudyQuery;
import org.jabref.model.util.FileUpdateMonitor;
import org.jabref.preferences.GeneralPreferences;

import org.eclipse.jgit.api.errors.GitAPIException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * This class manages all aspects of the study process related to the repository.
 *
 * It includes the parsing of the study definition file (study.bib) into a Study instance,
 * the structured persistence of the crawling results for the study within the file based repository,
 * as well as the sharing, and versioning of results using git.
 */
class StudyRepository {
    // Tests work with study.yml
    private static final String STUDY_DEFINITION_FILE_NAME = &quot;study.yml&quot;;
<span class="fc" id="L54">    private static final Logger LOGGER = LoggerFactory.getLogger(StudyRepository.class);</span>
<span class="fc" id="L55">    private static final Pattern MATCHCOLON = Pattern.compile(&quot;:&quot;);</span>
<span class="fc" id="L56">    private static final Pattern MATCHILLEGALCHARACTERS = Pattern.compile(&quot;[^A-Za-z0-9_.\\s=-]&quot;);</span>
    // Currently we make assumptions about the configuration: the remotes, work and search branch names
    private static final String REMOTE = &quot;origin&quot;;
    private static final String WORK_BRANCH = &quot;work&quot;;
    private static final String SEARCH_BRANCH = &quot;search&quot;;

    private final Path repositoryPath;
    private final Path studyDefinitionFile;
    private final SlrGitHandler gitHandler;
    private final Study study;
    private final GeneralPreferences generalPreferences;
    private final ImportFormatPreferences importFormatPreferences;
    private final FileUpdateMonitor fileUpdateMonitor;
    private final SavePreferences savePreferences;
    private final BibEntryTypesManager bibEntryTypesManager;

    /**
     * Creates a study repository.
     *
     * @param pathToRepository Where the repository root is located.
     * @param gitHandler       The git handler that managages any interaction with the remote repository
     * @throws IllegalArgumentException If the repository root directory does not exist, or the root directory does not
     *                                  contain the study definition file.
     * @throws IOException              Thrown if the given repository does not exists, or the study definition file
     *                                  does not exist
     * @throws ParseException           Problem parsing the study definition file.
     */
    public StudyRepository(Path pathToRepository,
                           SlrGitHandler gitHandler,
                           GeneralPreferences generalPreferences,
                           ImportFormatPreferences importFormatPreferences,
                           FileUpdateMonitor fileUpdateMonitor,
                           SavePreferences savePreferences,
<span class="fc" id="L89">                           BibEntryTypesManager bibEntryTypesManager) throws IOException, ParseException {</span>
<span class="fc" id="L90">        this.repositoryPath = pathToRepository;</span>
<span class="fc" id="L91">        this.gitHandler = gitHandler;</span>
<span class="fc" id="L92">        this.generalPreferences = generalPreferences;</span>
<span class="fc" id="L93">        this.importFormatPreferences = importFormatPreferences;</span>
<span class="fc" id="L94">        this.fileUpdateMonitor = fileUpdateMonitor;</span>
<span class="fc" id="L95">        this.studyDefinitionFile = Path.of(repositoryPath.toString(), STUDY_DEFINITION_FILE_NAME);</span>
<span class="fc" id="L96">        this.savePreferences = savePreferences;</span>
<span class="fc" id="L97">        this.bibEntryTypesManager = bibEntryTypesManager;</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (Files.notExists(repositoryPath)) {</span>
<span class="fc" id="L100">            throw new IOException(&quot;The given repository does not exists.&quot;);</span>
        }
        try {
<span class="fc" id="L103">            gitHandler.createCommitOnCurrentBranch(&quot;Save changes before searching.&quot;, false);</span>
<span class="fc" id="L104">            gitHandler.checkoutBranch(WORK_BRANCH);</span>
<span class="fc" id="L105">            updateWorkAndSearchBranch();</span>
<span class="nc" id="L106">        } catch (GitAPIException e) {</span>
<span class="nc" id="L107">            LOGGER.error(&quot;Could not checkout work branch&quot;);</span>
<span class="fc" id="L108">        }</span>
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">        if (Files.notExists(studyDefinitionFile)) {</span>
<span class="nc" id="L110">            throw new IOException(&quot;The study definition file does not exist in the given repository.&quot;);</span>
        }
<span class="fc" id="L112">        study = parseStudyFile();</span>
        try {
            // Update repository structure on work branch in case of changes
<span class="fc" id="L115">            setUpRepositoryStructure();</span>
<span class="fc" id="L116">            gitHandler.createCommitOnCurrentBranch(&quot;Setup/Update Repository Structure&quot;, false);</span>
<span class="fc" id="L117">            gitHandler.checkoutBranch(SEARCH_BRANCH);</span>
            // If study definition does not exist on this branch or was changed on work branch, copy it from work
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">            boolean studyDefinitionDoesNotExistOrChanged = !(Files.exists(studyDefinitionFile) &amp;&amp; new StudyYamlParser().parseStudyYamlFile(studyDefinitionFile).equalsBesideLastSearchDate(study));</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">            if (studyDefinitionDoesNotExistOrChanged) {</span>
<span class="nc" id="L121">                new StudyYamlParser().writeStudyYamlFile(study, studyDefinitionFile);</span>
            }
<span class="fc" id="L123">            this.setUpRepositoryStructure();</span>
<span class="fc" id="L124">            gitHandler.createCommitOnCurrentBranch(&quot;Setup/Update Repository Structure&quot;, false);</span>
<span class="nc" id="L125">        } catch (GitAPIException e) {</span>
<span class="nc" id="L126">            LOGGER.error(&quot;Could not checkout search branch.&quot;);</span>
<span class="fc" id="L127">        }</span>
        try {
<span class="fc" id="L129">            gitHandler.checkoutBranch(WORK_BRANCH);</span>
<span class="nc" id="L130">        } catch (GitAPIException e) {</span>
<span class="nc" id="L131">            LOGGER.error(&quot;Could not checkout work branch&quot;);</span>
<span class="fc" id="L132">        }</span>
<span class="fc" id="L133">    }</span>

    /**
     * Returns entries stored in the repository for a certain query and fetcher
     */
    public BibDatabaseContext getFetcherResultEntries(String query, String fetcherName) throws IOException {
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">        if (Files.exists(getPathToFetcherResultFile(query, fetcherName))) {</span>
<span class="fc" id="L140">            return OpenDatabase.loadDatabase(getPathToFetcherResultFile(query, fetcherName), generalPreferences, importFormatPreferences, fileUpdateMonitor).getDatabaseContext();</span>
        }
<span class="nc" id="L142">        return new BibDatabaseContext();</span>
    }

    /**
     * Returns the merged entries stored in the repository for a certain query
     */
    public BibDatabaseContext getQueryResultEntries(String query) throws IOException {
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (Files.exists(getPathToQueryResultFile(query))) {</span>
<span class="fc" id="L150">            return OpenDatabase.loadDatabase(getPathToQueryResultFile(query), generalPreferences, importFormatPreferences, fileUpdateMonitor).getDatabaseContext();</span>
        }
<span class="nc" id="L152">        return new BibDatabaseContext();</span>
    }

    /**
     * Returns the merged entries stored in the repository for all queries
     */
    public BibDatabaseContext getStudyResultEntries() throws IOException {
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">        if (Files.exists(getPathToStudyResultFile())) {</span>
<span class="fc" id="L160">            return OpenDatabase.loadDatabase(getPathToStudyResultFile(), generalPreferences, importFormatPreferences, fileUpdateMonitor).getDatabaseContext();</span>
        }
<span class="nc" id="L162">        return new BibDatabaseContext();</span>
    }

    /**
     * The study definition file contains all the definitions of a study. This method extracts this study from the yaml study definition file
     *
     * @return Returns the BibEntries parsed from the study definition file.
     * @throws IOException Problem opening the input stream.
     */
    private Study parseStudyFile() throws IOException {
<span class="fc" id="L172">        return new StudyYamlParser().parseStudyYamlFile(studyDefinitionFile);</span>
    }

    /**
     * Returns all query strings of the study definition
     *
     * @return List of all queries as Strings.
     */
    public List&lt;String&gt; getSearchQueryStrings() {
<span class="fc" id="L181">        return study.getQueries()</span>
<span class="fc" id="L182">                    .parallelStream()</span>
<span class="fc" id="L183">                    .map(StudyQuery::getQuery)</span>
<span class="fc" id="L184">                    .collect(Collectors.toList());</span>
    }

    /**
     * Extracts all active fetchers from the library entries.
     *
     * @return List of BibEntries of type Library
     * @throws IllegalArgumentException If a transformation from Library entry to LibraryDefinition fails
     */
    public List&lt;StudyDatabase&gt; getActiveLibraryEntries() throws IllegalArgumentException {
<span class="fc" id="L194">        return study.getDatabases()</span>
<span class="fc" id="L195">                    .parallelStream()</span>
<span class="fc" id="L196">                    .filter(StudyDatabase::isEnabled)</span>
<span class="fc" id="L197">                    .collect(Collectors.toList());</span>
    }

    public Study getStudy() {
<span class="fc" id="L201">        return study;</span>
    }

    /**
     * Persists the result locally and remotely by following the steps:
     * Precondition: Currently checking out work branch
     * &lt;ol&gt;
     *     &lt;li&gt;Update the work and search branch&lt;/li&gt;
     *     &lt;li&gt;Persist the results on the search branch&lt;/li&gt;
     *     &lt;li&gt;Manually patch the diff of the search branch onto the work branch (as the merging will not work in
     *     certain cases without a conflict as it is context sensitive. But for this use case we do not need it to be
     *     context sensitive. So we can just prepend the patch without checking the &quot;context&quot; lines.&lt;/li&gt;
     *     &lt;li&gt;Update the remote tracking branches of the work and search branch&lt;/li&gt;
     * &lt;/ol&gt;
     */
    public void persist(List&lt;QueryResult&gt; crawlResults) throws IOException, GitAPIException, SaveException {
<span class="fc" id="L217">        updateWorkAndSearchBranch();</span>
<span class="fc" id="L218">        study.setLastSearchDate(LocalDate.now());</span>
<span class="fc" id="L219">        persistStudy();</span>
<span class="fc" id="L220">        gitHandler.createCommitOnCurrentBranch(&quot;Update search date&quot;, true);</span>
<span class="fc" id="L221">        gitHandler.checkoutBranch(SEARCH_BRANCH);</span>
<span class="fc" id="L222">        persistResults(crawlResults);</span>
<span class="fc" id="L223">        study.setLastSearchDate(LocalDate.now());</span>
<span class="fc" id="L224">        persistStudy();</span>
        try {
            // First commit changes to search branch branch and update remote
<span class="fc" id="L227">            String commitMessage = &quot;Conducted search: &quot; + LocalDateTime.now().truncatedTo(ChronoUnit.SECONDS);</span>
<span class="fc" id="L228">            boolean newSearchResults = gitHandler.createCommitOnCurrentBranch(commitMessage, false);</span>
<span class="fc" id="L229">            gitHandler.checkoutBranch(WORK_BRANCH);</span>
<span class="pc bpc" id="L230" title="1 of 2 branches missed.">            if (!newSearchResults) {</span>
<span class="fc" id="L231">                return;</span>
            }
            // Patch new results into work branch
<span class="nc" id="L234">            gitHandler.appendLatestSearchResultsOntoCurrentBranch(commitMessage + &quot; - Patch&quot;, SEARCH_BRANCH);</span>
            // Update both remote tracked branches
<span class="nc" id="L236">            updateRemoteSearchAndWorkBranch();</span>
<span class="nc" id="L237">        } catch (GitAPIException e) {</span>
<span class="nc" id="L238">            LOGGER.error(&quot;Updating remote repository failed&quot;, e);</span>
<span class="nc" id="L239">        }</span>
<span class="nc" id="L240">    }</span>

    /**
     * Update the remote tracking branches of the work and search branches
     * The currently checked out branch is not changed if the method is executed successfully
     */
    private void updateRemoteSearchAndWorkBranch() throws IOException, GitAPIException {
<span class="nc" id="L247">        String currentBranch = gitHandler.getCurrentlyCheckedOutBranch();</span>
<span class="nc" id="L248">        gitHandler.checkoutBranch(SEARCH_BRANCH);</span>
<span class="nc" id="L249">        gitHandler.pushCommitsToRemoteRepository();</span>
<span class="nc" id="L250">        gitHandler.checkoutBranch(WORK_BRANCH);</span>
<span class="nc" id="L251">        gitHandler.pushCommitsToRemoteRepository();</span>
<span class="nc" id="L252">        gitHandler.checkoutBranch(currentBranch);</span>
<span class="nc" id="L253">    }</span>

    /**
     * Updates the local work and search branches with changes from their tracking remote branches
     * The currently checked out branch is not changed if the method is executed successfully
     */
    private void updateWorkAndSearchBranch() throws IOException, GitAPIException {
<span class="fc" id="L260">        String currentBranch = gitHandler.getCurrentlyCheckedOutBranch();</span>
<span class="fc" id="L261">        gitHandler.checkoutBranch(SEARCH_BRANCH);</span>
<span class="fc" id="L262">        gitHandler.pullOnCurrentBranch();</span>
<span class="fc" id="L263">        gitHandler.checkoutBranch(WORK_BRANCH);</span>
<span class="fc" id="L264">        gitHandler.pullOnCurrentBranch();</span>
<span class="fc" id="L265">        gitHandler.checkoutBranch(currentBranch);</span>
<span class="fc" id="L266">    }</span>

    private void persistStudy() throws IOException {
<span class="fc" id="L269">        new StudyYamlParser().writeStudyYamlFile(study, studyDefinitionFile);</span>
<span class="fc" id="L270">    }</span>

    /**
     * Create for each query a folder, and for each fetcher a bib file in the query folder to store its results.
     */
    private void setUpRepositoryStructure() throws IOException {
        // Cannot use stream here since IOException has to be thrown
<span class="fc" id="L277">        StudyDatabaseToFetcherConverter converter = new StudyDatabaseToFetcherConverter(this.getActiveLibraryEntries(), importFormatPreferences);</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">        for (String query : this.getSearchQueryStrings()) {</span>
<span class="fc" id="L279">            createQueryResultFolder(query);</span>
<span class="fc" id="L280">            converter.getActiveFetchers()</span>
<span class="fc" id="L281">                     .forEach(searchBasedFetcher -&gt; createFetcherResultFile(query, searchBasedFetcher));</span>
<span class="fc" id="L282">            createQueryResultFile(query);</span>
<span class="fc" id="L283">        }</span>
<span class="fc" id="L284">        createStudyResultFile();</span>
<span class="fc" id="L285">    }</span>

    /**
     * Creates a folder using the query and its corresponding query id.
     * This folder name is unique for each query, as long as the query id in the study definition is unique for each query.
     *
     * @param query The query the folder is created for
     */
    private void createQueryResultFolder(String query) throws IOException {
<span class="fc" id="L294">        Path queryResultFolder = getPathToQueryDirectory(query);</span>
<span class="fc" id="L295">        createFolder(queryResultFolder);</span>
<span class="fc" id="L296">    }</span>

    private void createFolder(Path folder) throws IOException {
<span class="fc bfc" id="L299" title="All 2 branches covered.">        if (Files.notExists(folder)) {</span>
<span class="fc" id="L300">            Files.createDirectory(folder);</span>
        }
<span class="fc" id="L302">    }</span>

    private void createFetcherResultFile(String query, SearchBasedFetcher searchBasedFetcher) {
<span class="fc" id="L305">        String fetcherName = searchBasedFetcher.getName();</span>
<span class="fc" id="L306">        Path fetcherResultFile = getPathToFetcherResultFile(query, fetcherName);</span>
<span class="fc" id="L307">        createBibFile(fetcherResultFile);</span>
<span class="fc" id="L308">    }</span>

    private void createQueryResultFile(String query) {
<span class="fc" id="L311">        Path queryResultFile = getPathToFetcherResultFile(query, &quot;result&quot;);</span>
<span class="fc" id="L312">        createBibFile(queryResultFile);</span>
<span class="fc" id="L313">    }</span>

    private void createStudyResultFile() {
<span class="fc" id="L316">        createBibFile(getPathToStudyResultFile());</span>
<span class="fc" id="L317">    }</span>

    private void createBibFile(Path file) {
<span class="fc bfc" id="L320" title="All 2 branches covered.">        if (Files.notExists(file)) {</span>
            try {
<span class="fc" id="L322">                Files.createFile(file);</span>
<span class="nc" id="L323">            } catch (IOException e) {</span>
<span class="nc" id="L324">                throw new IllegalStateException(&quot;Error during creation of repository structure.&quot;, e);</span>
<span class="fc" id="L325">            }</span>
        }
<span class="fc" id="L327">    }</span>

    /**
     * Returns a string that can be used as a folder name.
     * This removes all characters from the query that are illegal for directory names.
     * Structure: ID-trimmed query
     *
     * Examples:
     * Input: '(title: test-title AND abstract: Test)' as a query entry with id 12345678
     * Output: '12345678 - title= test-title AND abstract= Test'
     *
     * Input: 'abstract: Test*' as a query entry with id 87654321
     * Output: '87654321 - abstract= Test'
     *
     * Input: '&quot;test driven&quot;' as a query entry with id 12348765
     * Output: '12348765 - test driven'
     *
     * @param query that is trimmed and combined with its query id
     * @return a unique folder name for any query.
     */
    private String trimNameAndAddID(String query) {
        // Replace all field: with field= for folder name
<span class="fc" id="L349">        String trimmedNamed = MATCHCOLON.matcher(query).replaceAll(&quot;=&quot;);</span>
<span class="fc" id="L350">        trimmedNamed = MATCHILLEGALCHARACTERS.matcher(trimmedNamed).replaceAll(&quot;&quot;);</span>
<span class="fc" id="L351">        String id = computeIDForQuery(query);</span>
        // Whole path has to be shorter than 260
<span class="fc" id="L353">        int remainingPathLength = 220 - studyDefinitionFile.toString().length() - id.length();</span>
<span class="pc bpc" id="L354" title="1 of 2 branches missed.">        if (query.length() &gt; remainingPathLength) {</span>
<span class="nc" id="L355">            trimmedNamed = query.substring(0, remainingPathLength);</span>
        }
<span class="fc" id="L357">        return id + &quot; - &quot; + trimmedNamed;</span>
    }

    /**
     * Helper to compute the query id for folder name creation.
     */
    private String computeIDForQuery(String query) {
<span class="fc" id="L364">        return String.valueOf(query.hashCode());</span>
    }

    /**
     * Persists the crawling results in the local file based repository.
     *
     * @param crawlResults The results that shall be persisted.
     */
    private void persistResults(List&lt;QueryResult&gt; crawlResults) throws IOException, SaveException {
<span class="fc" id="L373">        DatabaseMerger merger = new DatabaseMerger(importFormatPreferences.getKeywordSeparator());</span>
<span class="fc" id="L374">        BibDatabase newStudyResultEntries = new BibDatabase();</span>

<span class="fc bfc" id="L376" title="All 2 branches covered.">        for (QueryResult result : crawlResults) {</span>
<span class="fc" id="L377">            BibDatabase queryResultEntries = new BibDatabase();</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">            for (FetchResult fetcherResult : result.getResultsPerFetcher()) {</span>
<span class="fc" id="L379">                BibDatabase fetcherEntries = fetcherResult.getFetchResult();</span>
<span class="fc" id="L380">                BibDatabaseContext existingFetcherResult = getFetcherResultEntries(result.getQuery(), fetcherResult.getFetcherName());</span>

                // Merge new entries into fetcher result file
<span class="fc" id="L383">                merger.merge(existingFetcherResult.getDatabase(), fetcherEntries);</span>

                // Create citation keys for all entries that do not have one
<span class="fc" id="L386">                generateCiteKeys(existingFetcherResult, fetcherEntries);</span>

                // Aggregate each fetcher result into the query result
<span class="fc" id="L389">                merger.merge(queryResultEntries, fetcherEntries);</span>

<span class="fc" id="L391">                writeResultToFile(getPathToFetcherResultFile(result.getQuery(), fetcherResult.getFetcherName()), existingFetcherResult.getDatabase());</span>
<span class="fc" id="L392">            }</span>
<span class="fc" id="L393">            BibDatabase existingQueryEntries = getQueryResultEntries(result.getQuery()).getDatabase();</span>

            // Merge new entries into query result file
<span class="fc" id="L396">            merger.merge(existingQueryEntries, queryResultEntries);</span>
            // Aggregate all new entries for every query into the study result
<span class="fc" id="L398">            merger.merge(newStudyResultEntries, queryResultEntries);</span>

<span class="fc" id="L400">            writeResultToFile(getPathToQueryResultFile(result.getQuery()), existingQueryEntries);</span>
<span class="fc" id="L401">        }</span>
<span class="fc" id="L402">        BibDatabase existingStudyResultEntries = getStudyResultEntries().getDatabase();</span>

        // Merge new entries into study result file
<span class="fc" id="L405">        merger.merge(existingStudyResultEntries, newStudyResultEntries);</span>

<span class="fc" id="L407">        writeResultToFile(getPathToStudyResultFile(), existingStudyResultEntries);</span>
<span class="fc" id="L408">    }</span>

    private void generateCiteKeys(BibDatabaseContext existingEntries, BibDatabase targetEntries) {
<span class="fc" id="L411">        CitationKeyGenerator citationKeyGenerator = new CitationKeyGenerator(existingEntries, savePreferences.getCitationKeyPatternPreferences());</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">        targetEntries.getEntries().stream().filter(bibEntry -&gt; !bibEntry.hasCitationKey()).forEach(citationKeyGenerator::generateAndSetKey);</span>
<span class="fc" id="L413">    }</span>

    private void writeResultToFile(Path pathToFile, BibDatabase entries) throws IOException, SaveException {
<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        if (!Files.exists(pathToFile)) {</span>
<span class="nc" id="L417">            Files.createFile(pathToFile);</span>
        }
<span class="fc" id="L419">        try (Writer fileWriter = new FileWriter(pathToFile.toFile())) {</span>
<span class="fc" id="L420">            BibWriter bibWriter = new BibWriter(fileWriter, OS.NEWLINE);</span>
<span class="fc" id="L421">            BibtexDatabaseWriter databaseWriter = new BibtexDatabaseWriter(bibWriter, generalPreferences, savePreferences, bibEntryTypesManager);</span>
<span class="fc" id="L422">            databaseWriter.saveDatabase(new BibDatabaseContext(entries));</span>
<span class="nc" id="L423">        } catch (UnsupportedCharsetException ex) {</span>
<span class="nc" id="L424">            throw new SaveException(Localization.lang(&quot;Character encoding '%0' is not supported.&quot;, generalPreferences.getDefaultEncoding().displayName()), ex);</span>
<span class="nc" id="L425">        } catch (IOException ex) {</span>
<span class="nc" id="L426">            throw new SaveException(&quot;Problems saving: &quot; + ex, ex);</span>
<span class="fc" id="L427">        }</span>
<span class="fc" id="L428">    }</span>

    private Path getPathToFetcherResultFile(String query, String fetcherName) {
<span class="fc" id="L431">        return Path.of(repositoryPath.toString(), trimNameAndAddID(query), fetcherName + &quot;.bib&quot;);</span>
    }

    private Path getPathToQueryResultFile(String query) {
<span class="fc" id="L435">        return Path.of(repositoryPath.toString(), trimNameAndAddID(query), &quot;result.bib&quot;);</span>
    }

    private Path getPathToStudyResultFile() {
<span class="fc" id="L439">        return Path.of(repositoryPath.toString(), &quot;studyResult.bib&quot;);</span>
    }

    private Path getPathToQueryDirectory(String query) {
<span class="fc" id="L443">        return Path.of(repositoryPath.toString(), trimNameAndAddID(query));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>