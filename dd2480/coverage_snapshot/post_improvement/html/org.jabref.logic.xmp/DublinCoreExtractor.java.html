<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DublinCoreExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.xmp</a> &gt; <span class="el_source">DublinCoreExtractor.java</span></div><h1>DublinCoreExtractor.java</h1><pre class="source lang-java linenums">package org.jabref.logic.xmp;

import java.io.IOException;
import java.util.Calendar;
import java.util.Comparator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;

import org.jabref.logic.TypedBibEntry;
import org.jabref.model.database.BibDatabaseMode;
import org.jabref.model.entry.Author;
import org.jabref.model.entry.AuthorList;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.Month;
import org.jabref.model.entry.field.Field;
import org.jabref.model.entry.field.FieldFactory;
import org.jabref.model.entry.field.StandardField;
import org.jabref.model.entry.field.UnknownField;
import org.jabref.model.entry.types.EntryTypeFactory;
import org.jabref.model.strings.StringUtil;

import org.apache.xmpbox.DateConverter;
import org.apache.xmpbox.schema.DublinCoreSchema;

public class DublinCoreExtractor {

    private final DublinCoreSchema dcSchema;
    private final XmpPreferences xmpPreferences;

    private final BibEntry bibEntry;

    /**
     * @param dcSchema      Metadata in DublinCore format.
     * @param resolvedEntry The BibEntry object, which is filled during metadata extraction.
     */
<span class="fc" id="L41">    public DublinCoreExtractor(DublinCoreSchema dcSchema, XmpPreferences xmpPreferences, BibEntry resolvedEntry) {</span>
<span class="fc" id="L42">        this.dcSchema = dcSchema;</span>
<span class="fc" id="L43">        this.xmpPreferences = xmpPreferences;</span>

<span class="fc" id="L45">        this.bibEntry = resolvedEntry;</span>
<span class="fc" id="L46">    }</span>

    /**
     * Editor in BibTex - Contributor in DublinCore
     */
    private void extractEditor() {
<span class="fc" id="L52">        List&lt;String&gt; contributors = dcSchema.getContributors();</span>
<span class="pc bpc" id="L53" title="3 of 4 branches missed.">        if ((contributors != null) &amp;&amp; !contributors.isEmpty()) {</span>
<span class="nc" id="L54">            bibEntry.setField(StandardField.EDITOR, String.join(&quot; and &quot;, contributors));</span>
        }
<span class="fc" id="L56">    }</span>

    /**
     * Author in BibTex - Creator in DublinCore
     */
    private void extractAuthor() {
<span class="fc" id="L62">        List&lt;String&gt; creators = dcSchema.getCreators();</span>
<span class="pc bpc" id="L63" title="2 of 4 branches missed.">        if ((creators != null) &amp;&amp; !creators.isEmpty()) {</span>
<span class="fc" id="L64">           bibEntry.setField(StandardField.AUTHOR, String.join(&quot; and &quot;, creators));</span>
        }
<span class="fc" id="L66">    }</span>

    /**
     * Year in BibTex - Date in DublinCore is only the year information, because dc interprets empty months as January.
     * Tries to extract the month as well. In JabRef the bibtex/month/value is prioritized. &lt;br/&gt; The problem is the
     * default value of the calendar, which is always January, also if there is no month information in the xmp metdata.
     * The idea is, to reject all information with YYYY-01-01. In cases, where xmp is written with JabRef the month
     * property filled with jan will override this behavior and no data is lost. In the cases, where xmp is written by
     * another service, the assumption is, that the 1st January is not a publication date at all.
     */
    private void extractYearAndMonth() {
<span class="fc" id="L77">        List&lt;String&gt; dates = dcSchema.getUnqualifiedSequenceValueList(&quot;date&quot;);</span>
<span class="pc bpc" id="L78" title="1 of 4 branches missed.">        if ((dates != null) &amp;&amp; !dates.isEmpty()) {</span>
<span class="fc" id="L79">            String date = dates.get(0).trim();</span>
<span class="fc" id="L80">            Calendar calender = null;</span>
            try {
<span class="fc" id="L82">                calender = DateConverter.toCalendar(date);</span>
<span class="nc" id="L83">            } catch (IOException ignored) {</span>
                // Ignored
<span class="fc" id="L85">            }</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">            if (calender != null) {</span>
<span class="fc" id="L87">                bibEntry.setField(StandardField.YEAR, String.valueOf(calender.get(Calendar.YEAR)));</span>
<span class="fc" id="L88">                int monthNumber = calender.get(Calendar.MONTH) + 1;</span>
                // not the 1st of January
<span class="pc bpc" id="L90" title="3 of 4 branches missed.">                if (!((monthNumber == 1) &amp;&amp; (calender.get(Calendar.DAY_OF_MONTH) == 1))) {</span>
<span class="fc" id="L91">                    Month.getMonthByNumber(monthNumber)</span>
<span class="fc" id="L92">                         .ifPresent(month -&gt; bibEntry.setMonth(month));</span>
                }
            }
        }
<span class="fc" id="L96">    }</span>

    /**
     * Abstract in BibTex - Description in DublinCore
     */
    private void extractAbstract() {
<span class="fc" id="L102">        String description = dcSchema.getDescription();</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(description)) {</span>
<span class="fc" id="L104">            bibEntry.setField(StandardField.ABSTRACT, description);</span>
        }
<span class="fc" id="L106">    }</span>

    /**
     * DOI in BibTex - Identifier in DublinCore
     */
    private void extractDOI() {
<span class="fc" id="L112">        String identifier = dcSchema.getIdentifier();</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(identifier)) {</span>
<span class="fc" id="L114">            bibEntry.setField(StandardField.DOI, identifier);</span>
        }
<span class="fc" id="L116">    }</span>

    /**
     * Publisher are equivalent in both formats (BibTex and DublinCore)
     */
    private void extractPublisher() {
<span class="fc" id="L122">        List&lt;String&gt; publishers = dcSchema.getPublishers();</span>
<span class="pc bpc" id="L123" title="1 of 4 branches missed.">        if ((publishers != null) &amp;&amp; !publishers.isEmpty()) {</span>
<span class="fc" id="L124">            bibEntry.setField(StandardField.PUBLISHER, String.join(&quot; and &quot;, publishers));</span>
        }
<span class="fc" id="L126">    }</span>

    /**
     * This method sets all fields, which are custom in BibTeX and therefore supported by JabRef, but which are not
     * included in the DublinCore format.
     * &lt;p&gt;
     * The relation attribute of DublinCore is abused to insert these custom fields.
     */
    private void extractBibTexFields() {
<span class="fc" id="L135">        Predicate&lt;String&gt; isBibTeXElement = s -&gt; s.startsWith(&quot;bibtex/&quot;);</span>
<span class="fc" id="L136">        Consumer&lt;String&gt; splitBibTeXElement = s -&gt; {</span>
            // the default pattern is bibtex/key/value, but some fields contains url etc.
            // so the value property contains additional slashes, which makes the usage of
            // String#split complicated.
<span class="fc" id="L140">            String temp = s.substring(&quot;bibtex/&quot;.length());</span>
<span class="fc" id="L141">            int i = temp.indexOf('/');</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">            if (i != -1) {</span>
<span class="fc" id="L143">                Field key = FieldFactory.parseField(temp.substring(0, i));</span>
<span class="fc" id="L144">                String value = temp.substring(i + 1);</span>
<span class="fc" id="L145">                bibEntry.setField(key, value);</span>

                // only for month field - override value
                // workaround, because the date value of the xmp component of pdf box is corrupted
                // see also DublinCoreExtractor#extractYearAndMonth
<span class="fc bfc" id="L150" title="All 2 branches covered.">                if (StandardField.MONTH.equals(key)) {</span>
<span class="fc" id="L151">                    Optional&lt;Month&gt; parsedMonth = Month.parse(value);</span>
<span class="fc" id="L152">                    parsedMonth.ifPresent(bibEntry::setMonth);</span>
                }
            }
<span class="fc" id="L155">        };</span>
<span class="fc" id="L156">        List&lt;String&gt; relationships = dcSchema.getRelations();</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (relationships != null) {</span>
<span class="fc" id="L158">            relationships.stream()</span>
<span class="fc" id="L159">                         .filter(isBibTeXElement)</span>
<span class="fc" id="L160">                         .forEach(splitBibTeXElement);</span>
        }
<span class="fc" id="L162">    }</span>

    /**
     * Rights are equivalent in both formats (BibTex and DublinCore)
     */
    private void extractRights() {
<span class="fc" id="L168">        String rights = dcSchema.getRights();</span>
<span class="pc bpc" id="L169" title="1 of 2 branches missed.">        if (!StringUtil.isNullOrEmpty(rights)) {</span>
<span class="nc" id="L170">            bibEntry.setField(new UnknownField(&quot;rights&quot;), rights);</span>
        }
<span class="fc" id="L172">    }</span>

    /**
     * Source is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractSource() {
<span class="fc" id="L178">        String source = dcSchema.getSource();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        if (!StringUtil.isNullOrEmpty(source)) {</span>
<span class="nc" id="L180">            bibEntry.setField(new UnknownField(&quot;source&quot;), source);</span>
        }
<span class="fc" id="L182">    }</span>

    /**
     * Keywords in BibTex - Subjects in DublinCore
     */
    private void extractSubject() {
<span class="fc" id="L188">        List&lt;String&gt; subjects = dcSchema.getSubjects();</span>
<span class="pc bpc" id="L189" title="1 of 4 branches missed.">        if ((subjects != null) &amp;&amp; !subjects.isEmpty()) {</span>
<span class="fc" id="L190">            bibEntry.addKeywords(subjects, xmpPreferences.getKeywordSeparator());</span>
        }
<span class="fc" id="L192">    }</span>

    /**
     * Title is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractTitle() {
<span class="fc" id="L198">        String title = dcSchema.getTitle();</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(title)) {</span>
<span class="fc" id="L200">            bibEntry.setField(StandardField.TITLE, title);</span>
        }
<span class="fc" id="L202">    }</span>

    /**
     * Type is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractType() {
<span class="fc" id="L208">        List&lt;String&gt; types = dcSchema.getTypes();</span>
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">        if ((types != null) &amp;&amp; !types.isEmpty()) {</span>
<span class="fc" id="L210">            String type = types.get(0);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (!StringUtil.isNullOrEmpty(type)) {</span>
<span class="fc" id="L212">                bibEntry.setType(EntryTypeFactory.parse(type));</span>
            }
        }
<span class="fc" id="L215">    }</span>

    /**
     * Helper function for retrieving a BibEntry from the DublinCore metadata in a PDF file.
     * &lt;p&gt;
     * To understand how to get hold of a DublinCore have a look in the test cases for XMPUtil.
     * &lt;p&gt;
     * The BibEntry is build by mapping individual fields in the dublin core (like creator, title, subject) to fields in
     * a bibtex bibEntry. In case special &quot;bibtex/&quot; entries are contained, the normal dublin core fields take
     * precedence. For instance, the dublin core date takes precedence over bibtex/month.
     *
     * @return The bibEntry extracted from the document information.
     */
    public Optional&lt;BibEntry&gt; extractBibtexEntry() {
        // first extract &quot;bibtex/&quot; entries
<span class="fc" id="L230">        this.extractBibTexFields();</span>

        // then extract all &quot;standard&quot; dublin core entries
<span class="fc" id="L233">        this.extractEditor();</span>
<span class="fc" id="L234">        this.extractAuthor();</span>
<span class="fc" id="L235">        this.extractYearAndMonth();</span>
<span class="fc" id="L236">        this.extractAbstract();</span>
<span class="fc" id="L237">        this.extractDOI();</span>
<span class="fc" id="L238">        this.extractPublisher();</span>
<span class="fc" id="L239">        this.extractRights();</span>
<span class="fc" id="L240">        this.extractSource();</span>
<span class="fc" id="L241">        this.extractSubject();</span>
<span class="fc" id="L242">        this.extractTitle();</span>
<span class="fc" id="L243">        this.extractType();</span>

        // we pass a new BibEntry in the constructor which is never empty as it already consists of &quot;@misc&quot;
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (bibEntry.getFieldMap().isEmpty()) {</span>
<span class="fc" id="L247">            return Optional.empty();</span>
        }
<span class="fc" id="L249">        return Optional.of(bibEntry);</span>
    }

    /**
     * Bibtex-Fields used: editor, Field: 'dc:contributor'
     *
     * @param authors
     */
    private void fillContributor(String authors) {
<span class="nc" id="L258">        AuthorList list = AuthorList.parse(authors);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">        for (Author author : list.getAuthors()) {</span>
<span class="nc" id="L260">            dcSchema.addContributor(author.getFirstLast(false));</span>
<span class="nc" id="L261">        }</span>
<span class="nc" id="L262">    }</span>

    /**
     * Bibtex-Fields used: author, Field: 'dc:creator'
     *
     * @param creators
     */
    private void fillCreator(String creators) {
<span class="fc" id="L270">        AuthorList list = AuthorList.parse(creators);</span>

<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (Author author : list.getAuthors()) {</span>
<span class="fc" id="L273">            dcSchema.addCreator(author.getFirstLast(false));</span>
<span class="fc" id="L274">        }</span>
<span class="fc" id="L275">    }</span>

    /**
     * Bibtex-Fields used: year, month, Field: 'dc:date'
     */
    private void fillDate() {
<span class="nc" id="L281">        bibEntry.getFieldOrAlias(StandardField.DATE)</span>
<span class="nc" id="L282">                .ifPresent(publicationDate -&gt; dcSchema.addUnqualifiedSequenceValue(&quot;date&quot;, publicationDate));</span>
<span class="nc" id="L283">    }</span>

    /**
     * Bibtex-Fields used: abstract, Field: 'dc:description'
     *
     * @param description
     */
    private void fillDescription(String description) {
<span class="fc" id="L291">        dcSchema.setDescription(description);</span>
<span class="fc" id="L292">    }</span>

    /**
     * Bibtex-Fields used: doi, Field: 'dc:identifier'
     *
     * @param identifier
     */
    private void fillIdentifier(String identifier) {
<span class="fc" id="L300">        dcSchema.setIdentifier(identifier);</span>
<span class="fc" id="L301">    }</span>

    /**
     * Bibtex-Fields used: publisher, Field: dc:publisher
     *
     * @param publisher
     */
    private void fillPublisher(String publisher) {
<span class="fc" id="L309">        dcSchema.addPublisher(publisher);</span>
<span class="fc" id="L310">    }</span>

    /**
     * Bibtex-Fields used: keywords, Field: 'dc:subject'
     *
     * @param value
     */
    private void fillKeywords(String value) {
<span class="fc" id="L318">        String[] keywords = value.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        for (String keyword : keywords) {</span>
<span class="fc" id="L320">            dcSchema.addSubject(keyword.trim());</span>
        }
<span class="fc" id="L322">    }</span>

    /**
     * Bibtex-Fields used: title, Field: 'dc:title'
     *
     * @param title
     */
    private void fillTitle(String title) {
<span class="fc" id="L330">        dcSchema.setTitle(title);</span>
<span class="fc" id="L331">    }</span>

    /**
     * All others (+ citation key) get packaged in the relation attribute
     *
     * @param field Key of the metadata attribute
     * @param value Value of the metadata attribute
     */
    private void fillCustomField(Field field, String value) {
<span class="fc" id="L340">        dcSchema.addRelation(&quot;bibtex/&quot; + field.getName() + '/' + value);</span>
<span class="fc" id="L341">    }</span>

    public void fillDublinCoreSchema() {
        // Query privacy filter settings
<span class="fc" id="L345">        boolean useXmpPrivacyFilter = xmpPreferences.shouldUseXmpPrivacyFilter();</span>

<span class="fc" id="L347">        Set&lt;Entry&lt;Field, String&gt;&gt; fieldValues = new TreeSet&lt;&gt;(Comparator.comparing(fieldStringEntry -&gt; fieldStringEntry.getKey().getName()));</span>
<span class="fc" id="L348">        fieldValues.addAll(bibEntry.getFieldMap().entrySet());</span>
<span class="fc bfc" id="L349" title="All 2 branches covered.">        for (Entry&lt;Field, String&gt; field : fieldValues) {</span>
<span class="pc bpc" id="L350" title="1 of 4 branches missed.">            if (useXmpPrivacyFilter &amp;&amp; xmpPreferences.getXmpPrivacyFilter().contains(field.getKey())) {</span>
<span class="fc" id="L351">                continue;</span>
            }

<span class="pc bpc" id="L354" title="1 of 2 branches missed.">            if (StandardField.EDITOR.equals(field.getKey())) {</span>
<span class="nc" id="L355">                this.fillContributor(field.getValue());</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">            } else if (StandardField.AUTHOR.equals(field.getKey())) {</span>
<span class="fc" id="L357">                this.fillCreator(field.getValue());</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">            } else if (StandardField.YEAR.equals(field.getKey())) {</span>
<span class="nc" id="L359">                this.fillDate();</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">            } else if (StandardField.ABSTRACT.equals(field.getKey())) {</span>
<span class="fc" id="L361">                this.fillDescription(field.getValue());</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            } else if (StandardField.DOI.equals(field.getKey())) {</span>
<span class="fc" id="L363">                this.fillIdentifier(field.getValue());</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            } else if (StandardField.PUBLISHER.equals(field.getKey())) {</span>
<span class="fc" id="L365">                this.fillPublisher(field.getValue());</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">            } else if (StandardField.KEYWORDS.equals(field.getKey())) {</span>
<span class="fc" id="L367">                this.fillKeywords(field.getValue());</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">            } else if (StandardField.TITLE.equals(field.getKey())) {</span>
<span class="fc" id="L369">                this.fillTitle(field.getValue());</span>
            } else {
<span class="fc" id="L371">                this.fillCustomField(field.getKey(), field.getValue());</span>
            }
<span class="fc" id="L373">        }</span>

<span class="fc" id="L375">        dcSchema.setFormat(&quot;application/pdf&quot;);</span>

        // Bibtex-Fields used: entrytype, Field: 'dc:type'
<span class="fc" id="L378">        TypedBibEntry typedEntry = new TypedBibEntry(bibEntry, BibDatabaseMode.BIBTEX);</span>
<span class="fc" id="L379">        String o = typedEntry.getTypeForDisplay();</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (!o.isEmpty()) {</span>
<span class="fc" id="L381">            dcSchema.addType(o);</span>
        }
<span class="fc" id="L383">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>