<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="sv"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PreferencesMigrations.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.migrations</a> &gt; <span class="el_source">PreferencesMigrations.java</span></div><h1>PreferencesMigrations.java</h1><pre class="source lang-java linenums">package org.jabref.migrations;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.UnaryOperator;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;
import java.util.stream.Collectors;

import javafx.scene.control.TableColumn;

import org.jabref.gui.Globals;
import org.jabref.gui.maintable.ColumnPreferences;
import org.jabref.gui.maintable.MainTableColumnModel;
import org.jabref.logic.citationkeypattern.GlobalCitationKeyPattern;
import org.jabref.model.entry.field.SpecialField;
import org.jabref.model.entry.field.StandardField;
import org.jabref.model.entry.types.EntryTypeFactory;
import org.jabref.preferences.JabRefPreferences;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PreferencesMigrations {

<span class="fc" id="L31">    private static final Logger LOGGER = LoggerFactory.getLogger(PreferencesMigrations.class);</span>

    private PreferencesMigrations() {
    }

    /**
     * Perform checks and changes for users with a preference set from an older JabRef version.
     */
    public static void runMigrations() {
<span class="nc" id="L40">        Preferences mainPrefsNode = Preferences.userRoot().node(&quot;/org/jabref&quot;);</span>

<span class="nc" id="L42">        upgradePrefsToOrgJabRef(mainPrefsNode);</span>
<span class="nc" id="L43">        upgradeSortOrder(Globals.prefs);</span>
<span class="nc" id="L44">        upgradeFaultyEncodingStrings(Globals.prefs);</span>
<span class="nc" id="L45">        upgradeLabelPatternToCitationKeyPattern(Globals.prefs);</span>
<span class="nc" id="L46">        upgradeImportFileAndDirePatterns(Globals.prefs, mainPrefsNode);</span>
<span class="nc" id="L47">        upgradeStoredBibEntryTypes(Globals.prefs, mainPrefsNode);</span>
<span class="nc" id="L48">        upgradeKeyBindingsToJavaFX(Globals.prefs);</span>
<span class="nc" id="L49">        addCrossRefRelatedFieldsForAutoComplete(Globals.prefs);</span>
<span class="nc" id="L50">        upgradePreviewStyleFromReviewToComment(Globals.prefs);</span>
        // changeColumnVariableNamesFor51 needs to be run before upgradeColumnPre50Preferences to ensure
        // backwardcompatibility, as it copies the old values to new variable names and keeps th old sored with the old
        // variable names. However, the variables from 5.0 need to be copied to the new variable name too.
<span class="nc" id="L54">        changeColumnVariableNamesFor51(Globals.prefs);</span>
<span class="nc" id="L55">        upgradeColumnPreferences(Globals.prefs);</span>
<span class="nc" id="L56">        restoreVariablesForBackwardCompatibility(Globals.prefs);</span>
<span class="nc" id="L57">        upgradePreviewStyleAllowMarkdown(Globals.prefs);</span>
<span class="nc" id="L58">    }</span>

    /**
     * Migrate all preferences from net/sf/jabref to org/jabref
     */
    private static void upgradePrefsToOrgJabRef(Preferences mainPrefsNode) {
        try {
<span class="nc bnc" id="L65" title="All 2 branches missed.">            if (mainPrefsNode.childrenNames().length != 0) {</span>
                // skip further processing as prefs already have been migrated
<span class="nc" id="L67">                LOGGER.debug(&quot;New prefs node already exists with content - skipping migration&quot;);</span>
            } else {
<span class="nc bnc" id="L69" title="All 2 branches missed.">                if (mainPrefsNode.parent().parent().nodeExists(&quot;net/sf/jabref&quot;)) {</span>
<span class="nc" id="L70">                    LOGGER.info(&quot;Migrating old preferences.&quot;);</span>
<span class="nc" id="L71">                    Preferences oldNode = mainPrefsNode.parent().parent().node(&quot;net/sf/jabref&quot;);</span>
<span class="nc" id="L72">                    copyPrefsRecursively(oldNode, mainPrefsNode);</span>
                }
            }
<span class="nc" id="L75">        } catch (BackingStoreException ex) {</span>
<span class="nc" id="L76">            LOGGER.error(&quot;Migrating old preferences failed.&quot;, ex);</span>
<span class="nc" id="L77">        }</span>
<span class="nc" id="L78">    }</span>

    private static void copyPrefsRecursively(Preferences from, Preferences to) throws BackingStoreException {
<span class="nc bnc" id="L81" title="All 2 branches missed.">        for (String key : from.keys()) {</span>
<span class="nc" id="L82">            String newValue = from.get(key, &quot;&quot;);</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">            if (newValue.contains(&quot;net.sf&quot;)) {</span>
<span class="nc" id="L84">                newValue = newValue.replaceAll(&quot;net\\.sf&quot;, &quot;org&quot;);</span>
            }
<span class="nc" id="L86">            to.put(key, newValue);</span>
        }
<span class="nc bnc" id="L88" title="All 2 branches missed.">        for (String child : from.childrenNames()) {</span>
<span class="nc" id="L89">            Preferences childNode = from.node(child);</span>
<span class="nc" id="L90">            Preferences newChildNode = to.node(child);</span>
<span class="nc" id="L91">            copyPrefsRecursively(childNode, newChildNode);</span>
        }
<span class="nc" id="L93">    }</span>

    /**
     * Added from Jabref 2.11 beta 4 onwards to fix wrong encoding names
     */
    private static void upgradeFaultyEncodingStrings(JabRefPreferences prefs) {
<span class="nc" id="L99">        String defaultEncoding = prefs.get(JabRefPreferences.DEFAULT_ENCODING);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">        if (defaultEncoding == null) {</span>
<span class="nc" id="L101">            return;</span>
        }

<span class="nc" id="L104">        Map&lt;String, String&gt; encodingMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L105">        encodingMap.put(&quot;UTF8&quot;, &quot;UTF-8&quot;);</span>
<span class="nc" id="L106">        encodingMap.put(&quot;Cp1250&quot;, &quot;CP1250&quot;);</span>
<span class="nc" id="L107">        encodingMap.put(&quot;Cp1251&quot;, &quot;CP1251&quot;);</span>
<span class="nc" id="L108">        encodingMap.put(&quot;Cp1252&quot;, &quot;CP1252&quot;);</span>
<span class="nc" id="L109">        encodingMap.put(&quot;Cp1253&quot;, &quot;CP1253&quot;);</span>
<span class="nc" id="L110">        encodingMap.put(&quot;Cp1254&quot;, &quot;CP1254&quot;);</span>
<span class="nc" id="L111">        encodingMap.put(&quot;Cp1257&quot;, &quot;CP1257&quot;);</span>
<span class="nc" id="L112">        encodingMap.put(&quot;ISO8859_1&quot;, &quot;ISO8859-1&quot;);</span>
<span class="nc" id="L113">        encodingMap.put(&quot;ISO8859_2&quot;, &quot;ISO8859-2&quot;);</span>
<span class="nc" id="L114">        encodingMap.put(&quot;ISO8859_3&quot;, &quot;ISO8859-3&quot;);</span>
<span class="nc" id="L115">        encodingMap.put(&quot;ISO8859_4&quot;, &quot;ISO8859-4&quot;);</span>
<span class="nc" id="L116">        encodingMap.put(&quot;ISO8859_5&quot;, &quot;ISO8859-5&quot;);</span>
<span class="nc" id="L117">        encodingMap.put(&quot;ISO8859_6&quot;, &quot;ISO8859-6&quot;);</span>
<span class="nc" id="L118">        encodingMap.put(&quot;ISO8859_7&quot;, &quot;ISO8859-7&quot;);</span>
<span class="nc" id="L119">        encodingMap.put(&quot;ISO8859_8&quot;, &quot;ISO8859-8&quot;);</span>
<span class="nc" id="L120">        encodingMap.put(&quot;ISO8859_9&quot;, &quot;ISO8859-9&quot;);</span>
<span class="nc" id="L121">        encodingMap.put(&quot;ISO8859_13&quot;, &quot;ISO8859-13&quot;);</span>
<span class="nc" id="L122">        encodingMap.put(&quot;ISO8859_15&quot;, &quot;ISO8859-15&quot;);</span>
<span class="nc" id="L123">        encodingMap.put(&quot;KOI8_R&quot;, &quot;KOI8-R&quot;);</span>
<span class="nc" id="L124">        encodingMap.put(&quot;Big5_HKSCS&quot;, &quot;Big5-HKSCS&quot;);</span>
<span class="nc" id="L125">        encodingMap.put(&quot;EUC_JP&quot;, &quot;EUC-JP&quot;);</span>

<span class="nc bnc" id="L127" title="All 2 branches missed.">        if (encodingMap.containsKey(defaultEncoding)) {</span>
<span class="nc" id="L128">            prefs.put(JabRefPreferences.DEFAULT_ENCODING, encodingMap.get(defaultEncoding));</span>
        }
<span class="nc" id="L130">    }</span>

    /**
     * Upgrade the sort order preferences for the current version
     * The old preference is kept in case an old version of JabRef is used with
     * these preferences, but it is only used when the new preference does not
     * exist
     */
    private static void upgradeSortOrder(JabRefPreferences prefs) {

<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (prefs.get(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, null) == null) {</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">            if (prefs.getBoolean(&quot;exportInStandardOrder&quot;, false)) {</span>
<span class="nc" id="L142">                prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true);</span>
<span class="nc" id="L143">                prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, StandardField.AUTHOR.getName());</span>
<span class="nc" id="L144">                prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, StandardField.EDITOR.getName());</span>
<span class="nc" id="L145">                prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, StandardField.YEAR.getName());</span>
<span class="nc" id="L146">                prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false);</span>
<span class="nc" id="L147">                prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false);</span>
<span class="nc" id="L148">                prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">            } else if (prefs.getBoolean(&quot;exportInTitleOrder&quot;, false)) {</span>
                // exportInTitleOrder =&gt; title, author, editor
<span class="nc" id="L151">                prefs.putBoolean(JabRefPreferences.EXPORT_IN_SPECIFIED_ORDER, true);</span>
<span class="nc" id="L152">                prefs.put(JabRefPreferences.EXPORT_PRIMARY_SORT_FIELD, StandardField.TITLE.getName());</span>
<span class="nc" id="L153">                prefs.put(JabRefPreferences.EXPORT_SECONDARY_SORT_FIELD, StandardField.AUTHOR.getName());</span>
<span class="nc" id="L154">                prefs.put(JabRefPreferences.EXPORT_TERTIARY_SORT_FIELD, StandardField.EDITOR.getName());</span>
<span class="nc" id="L155">                prefs.putBoolean(JabRefPreferences.EXPORT_PRIMARY_SORT_DESCENDING, false);</span>
<span class="nc" id="L156">                prefs.putBoolean(JabRefPreferences.EXPORT_SECONDARY_SORT_DESCENDING, false);</span>
<span class="nc" id="L157">                prefs.putBoolean(JabRefPreferences.EXPORT_TERTIARY_SORT_DESCENDING, false);</span>
            }
        }
<span class="nc" id="L160">    }</span>

    /**
     * Migrate all customized entry types from versions &lt;=3.7
     */
    private static void upgradeStoredBibEntryTypes(JabRefPreferences prefs, Preferences mainPrefsNode) {

        try {
<span class="nc bnc" id="L168" title="All 2 branches missed.">            if (mainPrefsNode.nodeExists(JabRefPreferences.CUSTOMIZED_BIBTEX_TYPES) ||</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">                    mainPrefsNode.nodeExists(JabRefPreferences.CUSTOMIZED_BIBLATEX_TYPES)) {</span>
                // skip further processing as prefs already have been migrated
            } else {
<span class="nc" id="L172">                LOGGER.info(&quot;Migrating old custom entry types.&quot;);</span>
<span class="nc" id="L173">                CustomEntryTypePreferenceMigration.upgradeStoredBibEntryTypes(prefs.getGeneralPreferences().getDefaultBibDatabaseMode());</span>
            }
<span class="nc" id="L175">        } catch (BackingStoreException ex) {</span>
<span class="nc" id="L176">            LOGGER.error(&quot;Migrating old custom entry types failed.&quot;, ex);</span>
<span class="nc" id="L177">        }</span>
<span class="nc" id="L178">    }</span>

    /**
     * Migrate LabelPattern configuration from versions &lt;=3.5 to new CitationKeyPatterns
     */
    private static void upgradeLabelPatternToCitationKeyPattern(JabRefPreferences prefs) {

        try {
<span class="nc" id="L186">            Preferences mainPrefsNode = Preferences.userRoot().node(&quot;/org/jabref&quot;);</span>

            // Migrate default pattern
<span class="nc bnc" id="L189" title="All 2 branches missed.">            if (mainPrefsNode.get(JabRefPreferences.DEFAULT_CITATION_KEY_PATTERN, null) == null) {</span>
                // Check whether old defaultLabelPattern is set
<span class="nc" id="L191">                String oldDefault = mainPrefsNode.get(&quot;defaultLabelPattern&quot;, null);</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">                if (oldDefault != null) {</span>
<span class="nc" id="L193">                    prefs.put(JabRefPreferences.DEFAULT_CITATION_KEY_PATTERN, oldDefault);</span>
<span class="nc" id="L194">                    LOGGER.info(&quot;Upgraded old default key generator pattern '&quot; + oldDefault + &quot;' to new version.&quot;);</span>
                }
            }
            // Pref node already exists do not migrate from previous version
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (mainPrefsNode.nodeExists(JabRefPreferences.CITATION_KEY_PATTERNS_NODE)) {</span>
<span class="nc" id="L199">                return;</span>
            }

            // Migrate type specific patterns
            // Check for prefs node for Version 3.3-3.5
<span class="nc bnc" id="L204" title="All 2 branches missed.">            if (mainPrefsNode.nodeExists(&quot;logic/labelpattern&quot;)) {</span>
<span class="nc" id="L205">                migrateTypedKeyPrefs(prefs, mainPrefsNode.node(&quot;logic/labelpattern&quot;));</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">            } else if (mainPrefsNode.nodeExists(&quot;logic/labelPattern&quot;)) { // node used for version 3.0-3.2</span>
<span class="nc" id="L207">                migrateTypedKeyPrefs(prefs, mainPrefsNode.node(&quot;logic/labelPattern&quot;));</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">            } else if (mainPrefsNode.nodeExists(&quot;labelPattern&quot;)) { // node used for version &lt;3.0</span>
<span class="nc" id="L209">                migrateTypedKeyPrefs(prefs, mainPrefsNode.node(&quot;labelPattern&quot;));</span>
            }
<span class="nc" id="L211">        } catch (BackingStoreException e) {</span>
<span class="nc" id="L212">            LOGGER.error(&quot;Migrating old bibtexKeyPatterns failed.&quot;, e);</span>
<span class="nc" id="L213">        }</span>
<span class="nc" id="L214">    }</span>

    /**
     * Migrate Import File Name and Directory name Patterns from versions &lt;=4.0 to new BracketedPatterns
     */
    private static void migrateFileImportPattern(String oldStylePattern, String newStylePattern,
                                                 JabRefPreferences prefs, Preferences mainPrefsNode) {
<span class="fc" id="L221">        String preferenceFileNamePattern = mainPrefsNode.get(JabRefPreferences.IMPORT_FILENAMEPATTERN, null);</span>

<span class="pc bpc" id="L223" title="1 of 2 branches missed.">        if ((preferenceFileNamePattern != null) &amp;&amp;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                oldStylePattern.equals(preferenceFileNamePattern)) {</span>
            // Upgrade the old-style File Name pattern to new one:
<span class="fc" id="L226">            mainPrefsNode.put(JabRefPreferences.IMPORT_FILENAMEPATTERN, newStylePattern);</span>
<span class="fc" id="L227">            LOGGER.info(&quot;migrated old style &quot; + JabRefPreferences.IMPORT_FILENAMEPATTERN +</span>
                    &quot; value \&quot;&quot; + oldStylePattern + &quot;\&quot; to new value \&quot;&quot; +
                    newStylePattern + &quot;\&quot; in the preference file&quot;);

<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (prefs.hasKey(JabRefPreferences.IMPORT_FILENAMEPATTERN)) {</span>
                // Update also the key in the current application settings, if necessary:
<span class="fc" id="L233">                String fileNamePattern = prefs.get(JabRefPreferences.IMPORT_FILENAMEPATTERN);</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">                if (oldStylePattern.equals(fileNamePattern)) {</span>
<span class="fc" id="L235">                    prefs.put(JabRefPreferences.IMPORT_FILENAMEPATTERN, newStylePattern);</span>
<span class="fc" id="L236">                    LOGGER.info(&quot;migrated old style &quot; + JabRefPreferences.IMPORT_FILENAMEPATTERN +</span>
                            &quot; value \&quot;&quot; + oldStylePattern + &quot;\&quot; to new value \&quot;&quot; +
                            newStylePattern + &quot;\&quot; in the running application&quot;);
                }
            }
        }
<span class="fc" id="L242">    }</span>

    static void upgradeImportFileAndDirePatterns(JabRefPreferences prefs, Preferences mainPrefsNode) {

        // Migrate Import patterns
        // Check for prefs node for Version &lt;= 4.0
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        if (mainPrefsNode.get(JabRefPreferences.IMPORT_FILENAMEPATTERN, null) != null) {</span>

<span class="fc" id="L250">            String[] oldStylePatterns = new String[]{</span>
                    &quot;\\bibtexkey&quot;,
                    &quot;\\bibtexkey\\begin{title} - \\format[RemoveBrackets]{\\title}\\end{title}&quot;};
<span class="fc" id="L253">            String[] newStylePatterns = new String[]{&quot;[citationkey]&quot;,</span>
                    &quot;[citationkey] - [title]&quot;};

<span class="fc" id="L256">            String[] oldDisplayStylePattern = new String[]{&quot;bibtexkey&quot;, &quot;bibtexkey - title&quot;};</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">            for (int i = 0; i &lt; oldStylePatterns.length; i++) {</span>
<span class="fc" id="L259">                migrateFileImportPattern(oldStylePatterns[i], newStylePatterns[i], prefs, mainPrefsNode);</span>
            }
<span class="fc bfc" id="L261" title="All 2 branches covered.">            for (int i = 0; i &lt; oldDisplayStylePattern.length; i++) {</span>
<span class="fc" id="L262">                migrateFileImportPattern(oldDisplayStylePattern[i], newStylePatterns[i], prefs, mainPrefsNode);</span>
            }
        }
        // Directory preferences are not yet migrated, since it is not quote clear how to parse and reinterpret
        // the user defined old-style patterns, and the default pattern is &quot;&quot;.
<span class="fc" id="L267">    }</span>

    private static void upgradeKeyBindingsToJavaFX(JabRefPreferences prefs) {
<span class="nc" id="L270">        UnaryOperator&lt;String&gt; replaceKeys = (str) -&gt; {</span>
<span class="nc" id="L271">            String result = str.replace(&quot;ctrl &quot;, &quot;ctrl+&quot;);</span>
<span class="nc" id="L272">            result = result.replace(&quot;shift &quot;, &quot;shift+&quot;);</span>
<span class="nc" id="L273">            result = result.replace(&quot;alt &quot;, &quot;alt+&quot;);</span>
<span class="nc" id="L274">            result = result.replace(&quot;meta &quot;, &quot;meta+&quot;);</span>

<span class="nc" id="L276">            return result;</span>
        };

<span class="nc" id="L279">        List&lt;String&gt; keys = prefs.getStringList(JabRefPreferences.BINDINGS);</span>
<span class="nc" id="L280">        keys.replaceAll(replaceKeys);</span>
<span class="nc" id="L281">        prefs.putStringList(JabRefPreferences.BINDINGS, keys);</span>
<span class="nc" id="L282">    }</span>

    private static void addCrossRefRelatedFieldsForAutoComplete(JabRefPreferences prefs) {
        // LinkedHashSet because we want to retain the order and add new fields to the end
<span class="nc" id="L286">        Set&lt;String&gt; keys = new LinkedHashSet&lt;&gt;(prefs.getStringList(JabRefPreferences.AUTOCOMPLETER_COMPLETE_FIELDS));</span>
<span class="nc" id="L287">        keys.add(&quot;crossref&quot;);</span>
<span class="nc" id="L288">        keys.add(&quot;related&quot;);</span>
<span class="nc" id="L289">        keys.add(&quot;entryset&quot;);</span>
<span class="nc" id="L290">        prefs.putStringList(JabRefPreferences.AUTOCOMPLETER_COMPLETE_FIELDS, new ArrayList&lt;&gt;(keys));</span>
<span class="nc" id="L291">    }</span>

    private static void migrateTypedKeyPrefs(JabRefPreferences prefs, Preferences oldPatternPrefs)
            throws BackingStoreException {
<span class="nc" id="L295">        LOGGER.info(&quot;Found old Bibtex Key patterns which will be migrated to new version.&quot;);</span>

<span class="nc" id="L297">        GlobalCitationKeyPattern keyPattern = GlobalCitationKeyPattern.fromPattern(</span>
<span class="nc" id="L298">                prefs.get(JabRefPreferences.DEFAULT_CITATION_KEY_PATTERN));</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">        for (String key : oldPatternPrefs.keys()) {</span>
<span class="nc" id="L300">            keyPattern.addCitationKeyPattern(EntryTypeFactory.parse(key), oldPatternPrefs.get(key, null));</span>
        }
<span class="nc" id="L302">        prefs.storeGlobalCitationKeyPattern(keyPattern);</span>
<span class="nc" id="L303">    }</span>

    static void upgradePreviewStyleFromReviewToComment(JabRefPreferences prefs) {
<span class="fc" id="L306">        String currentPreviewStyle = prefs.getPreviewStyle();</span>
<span class="fc" id="L307">        String migratedStyle = currentPreviewStyle.replace(&quot;\\begin{review}&lt;BR&gt;&lt;BR&gt;&lt;b&gt;Review: &lt;/b&gt; \\format[HTMLChars]{\\review} \\end{review}&quot;, &quot;\\begin{comment}&lt;BR&gt;&lt;BR&gt;&lt;b&gt;Comment: &lt;/b&gt; \\format[HTMLChars]{\\comment} \\end{comment}&quot;)</span>
<span class="fc" id="L308">                                                  .replace(&quot;&lt;b&gt;&lt;i&gt;\\bibtextype&lt;/i&gt;&lt;a name=\&quot;\\bibtexkey\&quot;&gt;\\begin{bibtexkey} (\\bibtexkey)&lt;/a&gt;&quot;, &quot;&lt;b&gt;&lt;i&gt;\\bibtextype&lt;/i&gt;&lt;a name=\&quot;\\citationkey\&quot;&gt;\\begin{citationkey} (\\citationkey)&lt;/a&gt;&quot;)</span>
<span class="fc" id="L309">                                                  .replace(&quot;\\end{bibtexkey}&lt;/b&gt;&lt;br&gt;__NEWLINE__&quot;, &quot;\\end{citationkey}&lt;/b&gt;&lt;br&gt;__NEWLINE__&quot;);</span>
<span class="fc" id="L310">        prefs.setPreviewStyle(migratedStyle);</span>
<span class="fc" id="L311">    }</span>

    static void upgradePreviewStyleAllowMarkdown(JabRefPreferences prefs) {
<span class="fc" id="L314">        String currentPreviewStyle = prefs.getPreviewStyle();</span>
<span class="fc" id="L315">        String migratedStyle = currentPreviewStyle.replace(&quot;\\format[HTMLChars]{\\comment}&quot;, &quot;\\format[Markdown,HTMLChars]{\\comment}&quot;)</span>
<span class="fc" id="L316">                                                  .replace(&quot;&lt;b&gt;&lt;i&gt;\\bibtextype&lt;/i&gt;&lt;a name=\&quot;\\bibtexkey\&quot;&gt;\\begin{bibtexkey} (\\bibtexkey)&lt;/a&gt;&quot;, &quot;&lt;b&gt;&lt;i&gt;\\bibtextype&lt;/i&gt;&lt;a name=\&quot;\\citationkey\&quot;&gt;\\begin{citationkey} (\\citationkey)&lt;/a&gt;&quot;)</span>
<span class="fc" id="L317">                                                  .replace(&quot;\\end{bibtexkey}&lt;/b&gt;&lt;br&gt;__NEWLINE__&quot;, &quot;\\end{citationkey}&lt;/b&gt;&lt;br&gt;__NEWLINE__&quot;);</span>

<span class="fc" id="L319">        prefs.setPreviewStyle(migratedStyle);</span>
<span class="fc" id="L320">    }</span>

    /**
     * The former preferences default of columns was a simple list of strings (&quot;author;title;year;...&quot;). Since 5.0
     * the preferences store the type of the column too, so that the formerly hardwired columns like the graphic groups
     * column or the other icon columns can be reordered in the main table and behave like any other field column
     * (&quot;groups;linked_id;field:author;special:readstatus;extrafile:pdf;...&quot;).
     *
     * Simple strings are by default parsed as a FieldColumn, so there is nothing to do there, but the formerly hard
     * wired columns need to be added.
     *
     * In 5.1 variable names in JabRefPreferences have changed to offer backward compatibility with pre 5.0 releases
     * Pre 5.1: columnNames, columnWidths, columnSortTypes, columnSortOrder
     * Since 5.1: mainTableColumnNames, mainTableColumnWidths, mainTableColumnSortTypes, mainTableColumnSortOrder
     */
    static void upgradeColumnPreferences(JabRefPreferences preferences) {
        // Variable names have to be hardcoded here, since they are already changed in JabRefPreferences
<span class="fc" id="L337">        List&lt;String&gt; columnNames = preferences.getStringList(JabRefPreferences.COLUMN_NAMES);</span>
<span class="fc" id="L338">        List&lt;Double&gt; columnWidths = preferences.getStringList(JabRefPreferences.COLUMN_WIDTHS)</span>
<span class="fc" id="L339">                                               .stream()</span>
<span class="fc" id="L340">                                               .map(string -&gt; {</span>
                                                   try {
<span class="fc" id="L342">                                                       return Double.parseDouble(string);</span>
<span class="nc" id="L343">                                                   } catch (NumberFormatException e) {</span>
<span class="nc" id="L344">                                                       return ColumnPreferences.DEFAULT_COLUMN_WIDTH;</span>
                                                   }
                                               })
<span class="fc" id="L347">                                               .collect(Collectors.toList());</span>

        // &quot;field:&quot;
<span class="fc" id="L350">        String normalFieldTypeString = MainTableColumnModel.Type.NORMALFIELD.getName() + MainTableColumnModel.COLUMNS_QUALIFIER_DELIMITER;</span>

<span class="pc bpc" id="L352" title="1 of 4 branches missed.">        if (!columnNames.isEmpty() &amp;&amp; columnNames.stream().noneMatch(name -&gt; name.contains(normalFieldTypeString))) {</span>
<span class="fc" id="L353">            List&lt;MainTableColumnModel&gt; columns = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L354">            columns.add(new MainTableColumnModel(MainTableColumnModel.Type.GROUPS));</span>
<span class="fc" id="L355">            columns.add(new MainTableColumnModel(MainTableColumnModel.Type.FILES));</span>
<span class="fc" id="L356">            columns.add(new MainTableColumnModel(MainTableColumnModel.Type.LINKED_IDENTIFIER));</span>

<span class="fc bfc" id="L358" title="All 2 branches covered.">            for (int i = 0; i &lt; columnNames.size(); i++) {</span>
<span class="fc" id="L359">                String name = columnNames.get(i);</span>
<span class="fc" id="L360">                double columnWidth = ColumnPreferences.DEFAULT_COLUMN_WIDTH;</span>

<span class="fc" id="L362">                MainTableColumnModel.Type type = SpecialField.fromName(name)</span>
<span class="fc" id="L363">                                                             .map(field -&gt; MainTableColumnModel.Type.SPECIALFIELD)</span>
<span class="fc" id="L364">                                                             .orElse(MainTableColumnModel.Type.NORMALFIELD);</span>

<span class="pc bpc" id="L366" title="1 of 2 branches missed.">                if (i &lt; columnWidths.size()) {</span>
<span class="fc" id="L367">                    columnWidth = columnWidths.get(i);</span>
                }

<span class="fc" id="L370">                columns.add(new MainTableColumnModel(type, name, columnWidth));</span>
            }

<span class="fc" id="L373">            preferences.putStringList(JabRefPreferences.COLUMN_NAMES,</span>
<span class="fc" id="L374">                    columns.stream()</span>
<span class="fc" id="L375">                           .map(MainTableColumnModel::getName)</span>
<span class="fc" id="L376">                           .collect(Collectors.toList()));</span>

<span class="fc" id="L378">            preferences.putStringList(JabRefPreferences.COLUMN_WIDTHS,</span>
<span class="fc" id="L379">                    columns.stream()</span>
<span class="fc" id="L380">                           .map(MainTableColumnModel::getWidth)</span>
<span class="fc" id="L381">                           .map(Double::intValue)</span>
<span class="fc" id="L382">                           .map(Object::toString)</span>
<span class="fc" id="L383">                           .collect(Collectors.toList()));</span>

            // ASCENDING by default
<span class="fc" id="L386">            preferences.putStringList(JabRefPreferences.COLUMN_SORT_TYPES,</span>
<span class="fc" id="L387">                    columns.stream()</span>
<span class="fc" id="L388">                           .map(MainTableColumnModel::getSortType)</span>
<span class="fc" id="L389">                           .map(TableColumn.SortType::toString)</span>
<span class="fc" id="L390">                           .collect(Collectors.toList()));</span>
        }
<span class="fc" id="L392">    }</span>

    static void changeColumnVariableNamesFor51(JabRefPreferences preferences) {
        // The variable names have to be hardcoded, because they have changed between 5.0 and 5.1
<span class="fc" id="L396">        List&lt;String&gt; oldColumnNames = preferences.getStringList(&quot;columnNames&quot;);</span>
<span class="fc" id="L397">        List&lt;String&gt; columnNames = preferences.getStringList(JabRefPreferences.COLUMN_NAMES);</span>
<span class="pc bpc" id="L398" title="2 of 4 branches missed.">        if (!oldColumnNames.isEmpty() &amp;&amp; columnNames.isEmpty()) {</span>
<span class="fc" id="L399">            preferences.putStringList(JabRefPreferences.COLUMN_NAMES, preferences.getStringList(&quot;columnNames&quot;));</span>
<span class="fc" id="L400">            preferences.putStringList(JabRefPreferences.COLUMN_WIDTHS, preferences.getStringList(&quot;columnWidths&quot;));</span>
<span class="fc" id="L401">            preferences.putStringList(JabRefPreferences.COLUMN_SORT_TYPES, preferences.getStringList(&quot;columnSortTypes&quot;));</span>
<span class="fc" id="L402">            preferences.putStringList(JabRefPreferences.COLUMN_SORT_ORDER, preferences.getStringList(&quot;columnSortOrder&quot;));</span>
        }
<span class="fc" id="L404">    }</span>

    /**
     * In 5.0 the format of column names have changed. That made newer versions of JabRef preferences incompatible with
     * earlier versions of JabRef. As some complains came up, we decided to change the variable names and to clear the
     * variable contents if they are unreadable, so former versions of JabRef would automatically create preferences
     * they can deal with.
     */
    static void restoreVariablesForBackwardCompatibility(JabRefPreferences preferences) {
<span class="fc" id="L413">        List&lt;String&gt; oldColumnNames = preferences.getStringList(JabRefPreferences.COLUMN_NAMES);</span>
<span class="fc" id="L414">        List&lt;String&gt; fieldColumnNames = oldColumnNames.stream()</span>
<span class="fc bfc" id="L415" title="All 4 branches covered.">                                                      .filter(columnName -&gt; columnName.startsWith(&quot;field:&quot;) || columnName.startsWith(&quot;special:&quot;))</span>
<span class="fc" id="L416">                                                      .map(columnName -&gt; {</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">                                                          if (columnName.startsWith(&quot;field:&quot;)) {</span>
<span class="fc" id="L418">                                                              return columnName.substring(6);</span>
                                                          } else { // special
<span class="fc" id="L420">                                                              return columnName.substring(8);</span>
                                                          }
<span class="fc" id="L422">                                                      }).collect(Collectors.toList());</span>

<span class="pc bpc" id="L424" title="1 of 2 branches missed.">        if (!fieldColumnNames.isEmpty()) {</span>
<span class="fc" id="L425">            preferences.putStringList(&quot;columnNames&quot;, fieldColumnNames);</span>

<span class="fc" id="L427">            List&lt;String&gt; fieldColumnWidths = new ArrayList&lt;&gt;(Collections.emptyList());</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            for (int i = 0; i &lt; fieldColumnNames.size(); i++) {</span>
<span class="fc" id="L429">                fieldColumnWidths.add(&quot;100&quot;);</span>
            }
<span class="fc" id="L431">            preferences.putStringList(&quot;columnWidths&quot;, fieldColumnWidths);</span>

<span class="fc" id="L433">            preferences.put(&quot;columnSortTypes&quot;, &quot;&quot;);</span>
<span class="fc" id="L434">            preferences.put(&quot;columnSortOrder&quot;, &quot;&quot;);</span>
        }

        // Ensure font size is a parsable int variable
        try {
            // some versions stored the font size as double to the **same** key
            // since the preference store is type-safe, we need to add this workaround
<span class="fc" id="L441">            String fontSizeAsString = preferences.get(JabRefPreferences.MAIN_FONT_SIZE);</span>
<span class="fc" id="L442">            int fontSizeAsInt = (int) Math.round(Double.parseDouble(fontSizeAsString));</span>
<span class="fc" id="L443">            preferences.putInt(JabRefPreferences.MAIN_FONT_SIZE, fontSizeAsInt);</span>
<span class="nc" id="L444">        } catch (ClassCastException e) {</span>
            // already an integer
<span class="fc" id="L446">        }</span>
<span class="fc" id="L447">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>