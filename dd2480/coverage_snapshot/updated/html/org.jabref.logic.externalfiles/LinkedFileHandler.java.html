<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LinkedFileHandler.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.externalfiles</a> &gt; <span class="el_source">LinkedFileHandler.java</span></div><h1>LinkedFileHandler.java</h1><pre class="source lang-java linenums">package org.jabref.logic.externalfiles;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

import org.jabref.logic.util.io.FileUtil;
import org.jabref.model.database.BibDatabaseContext;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.LinkedFile;
import org.jabref.model.util.FileHelper;
import org.jabref.preferences.FilePreferences;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LinkedFileHandler {

<span class="fc" id="L24">    private static final Logger LOGGER = LoggerFactory.getLogger(LinkedFileHandler.class);</span>

    private final BibDatabaseContext databaseContext;
    private final FilePreferences filePreferences;
    private final BibEntry entry;

    private final LinkedFile fileEntry;

    public LinkedFileHandler(LinkedFile fileEntry,
                             BibEntry entry,
                             BibDatabaseContext databaseContext,
<span class="fc" id="L35">                             FilePreferences filePreferences) {</span>
<span class="fc" id="L36">        this.fileEntry = fileEntry;</span>
<span class="fc" id="L37">        this.entry = entry;</span>
<span class="fc" id="L38">        this.databaseContext = Objects.requireNonNull(databaseContext);</span>
<span class="fc" id="L39">        this.filePreferences = Objects.requireNonNull(filePreferences);</span>
<span class="fc" id="L40">    }</span>

    public boolean moveToDefaultDirectory() throws IOException {
<span class="fc" id="L43">        Optional&lt;Path&gt; targetDirectory = databaseContext.getFirstExistingFileDir(filePreferences);</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">        if (targetDirectory.isEmpty()) {</span>
<span class="fc" id="L45">            return false;</span>
        }

<span class="fc" id="L48">        Optional&lt;Path&gt; oldFile = fileEntry.findIn(databaseContext, filePreferences);</span>
<span class="fc bfc" id="L49" title="All 2 branches covered.">        if (oldFile.isEmpty()) {</span>
            // Could not find file
<span class="fc" id="L51">            return false;</span>
        }

<span class="fc" id="L54">        String targetDirectoryName = &quot;&quot;;</span>
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (!filePreferences.getFileDirectoryPattern().isEmpty()) {</span>
<span class="fc" id="L56">            targetDirectoryName = FileUtil.createDirNameFromPattern(</span>
<span class="fc" id="L57">                    databaseContext.getDatabase(),</span>
                    entry,
<span class="fc" id="L59">                    filePreferences.getFileDirectoryPattern());</span>
        }

<span class="fc" id="L62">        Path targetPath = targetDirectory.get().resolve(targetDirectoryName).resolve(oldFile.get().getFileName());</span>
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (Files.exists(targetPath)) {</span>
            // We do not overwrite already existing files
<span class="nc" id="L65">            LOGGER.debug(&quot;The file {} would have been moved to {}. However, there exists already a file with that name so we do nothing.&quot;, oldFile.get(), targetPath);</span>
<span class="nc" id="L66">            return false;</span>
        } else {
            // Make sure sub-directories exist
<span class="fc" id="L69">            Files.createDirectories(targetPath.getParent());</span>
        }

        // Move
<span class="fc" id="L73">        Files.move(oldFile.get(), targetPath);</span>

        // Update path
<span class="fc" id="L76">        fileEntry.setLink(relativize(targetPath));</span>
<span class="fc" id="L77">        return true;</span>
    }

    public boolean renameToSuggestedName() throws IOException {
<span class="fc" id="L81">        return renameToName(getSuggestedFileName(), false);</span>
    }

    public boolean renameToName(String targetFileName, boolean overwriteExistingFile) throws IOException {
<span class="fc" id="L85">        Optional&lt;Path&gt; oldFile = fileEntry.findIn(databaseContext, filePreferences);</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (oldFile.isEmpty()) {</span>
<span class="fc" id="L87">            return false;</span>
        }

<span class="fc" id="L90">        final Path oldPath = oldFile.get();</span>
<span class="fc" id="L91">        final Path newPath = oldPath.resolveSibling(targetFileName);</span>

<span class="fc" id="L93">        String expandedOldFilePath = oldPath.toString();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        boolean pathsDifferOnlyByCase = newPath.toString().equalsIgnoreCase(expandedOldFilePath)</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">                &amp;&amp; !newPath.toString().equals(expandedOldFilePath);</span>

        // Since Files.exists is sometimes not case-sensitive, the check pathsDifferOnlyByCase ensures that we
        // nonetheless rename files to a new name which just differs by case.
<span class="pc bpc" id="L99" title="3 of 6 branches missed.">        if (Files.exists(newPath) &amp;&amp; !pathsDifferOnlyByCase &amp;&amp; !overwriteExistingFile) {</span>
<span class="nc" id="L100">            LOGGER.debug(&quot;The file {} would have been moved to {}. However, there exists already a file with that name so we do nothing.&quot;, oldPath, newPath);</span>
<span class="nc" id="L101">            return false;</span>
        }

<span class="pc bpc" id="L104" title="3 of 6 branches missed.">        if (Files.exists(newPath) &amp;&amp; !pathsDifferOnlyByCase &amp;&amp; overwriteExistingFile) {</span>
<span class="nc" id="L105">            Files.createDirectories(newPath.getParent());</span>
<span class="nc" id="L106">            LOGGER.debug(&quot;Overwriting existing file {}&quot;, newPath);</span>
<span class="nc" id="L107">            Files.move(oldPath, newPath, StandardCopyOption.REPLACE_EXISTING);</span>
        } else {
<span class="fc" id="L109">            Files.createDirectories(newPath.getParent());</span>
<span class="fc" id="L110">            Files.move(oldPath, newPath);</span>
        }

        // Update path
<span class="fc" id="L114">        fileEntry.setLink(relativize(newPath));</span>

<span class="fc" id="L116">        return true;</span>
    }

    private String relativize(Path path) {
<span class="fc" id="L120">        List&lt;Path&gt; fileDirectories = databaseContext.getFileDirectories(filePreferences);</span>
<span class="fc" id="L121">        return FileUtil.relativize(path, fileDirectories).toString();</span>
    }

    public String getSuggestedFileName() {
<span class="fc" id="L125">        String oldFileName = fileEntry.getLink();</span>

<span class="fc" id="L127">        String extension = FileHelper.getFileExtension(oldFileName).orElse(fileEntry.getFileType());</span>
<span class="fc" id="L128">        return getSuggestedFileName(extension);</span>
    }

    public String getSuggestedFileName(String extension) {
<span class="fc" id="L132">        String targetFileName = FileUtil.createFileNameFromPattern(databaseContext.getDatabase(), entry, filePreferences.getFileNamePattern()).trim()</span>
                + '.'
                + extension;

        // Only create valid file names
<span class="fc" id="L137">        return FileUtil.getValidFileName(targetFileName);</span>
    }

    /**
     * Check to see if a file already exists in the target directory.  Search is not case sensitive.
     *
     * @return First identified path that matches an existing file.  This name can be used in subsequent calls to
     * override the existing file.
     */
    public Optional&lt;Path&gt; findExistingFile(LinkedFile flEntry, BibEntry entry, String targetFileName) {
        // The .get() is legal without check because the method will always return a value.
<span class="nc" id="L148">        Path targetFilePath = flEntry.findIn(databaseContext, filePreferences)</span>
<span class="nc" id="L149">                                     .get().getParent().resolve(targetFileName);</span>
<span class="nc" id="L150">        Path oldFilePath = flEntry.findIn(databaseContext, filePreferences).get();</span>
        // Check if file already exists in directory with different case.
        // This is necessary because other entries may have such a file.
<span class="nc" id="L153">        Optional&lt;Path&gt; matchedByDiffCase = Optional.empty();</span>
<span class="nc" id="L154">        try (Stream&lt;Path&gt; stream = Files.list(oldFilePath.getParent())) {</span>
<span class="nc" id="L155">            matchedByDiffCase = stream.filter(name -&gt; name.toString().equalsIgnoreCase(targetFilePath.toString()))</span>
<span class="nc" id="L156">                                      .findFirst();</span>
<span class="nc" id="L157">        } catch (IOException e) {</span>
<span class="nc" id="L158">            LOGGER.error(&quot;Could not get the list of files in target directory&quot;, e);</span>
<span class="nc" id="L159">        }</span>
<span class="nc" id="L160">        return matchedByDiffCase;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>