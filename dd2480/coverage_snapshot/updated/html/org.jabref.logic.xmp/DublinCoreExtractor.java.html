<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DublinCoreExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.xmp</a> &gt; <span class="el_source">DublinCoreExtractor.java</span></div><h1>DublinCoreExtractor.java</h1><pre class="source lang-java linenums">package org.jabref.logic.xmp;

import java.io.IOException;
import java.util.Calendar;
import java.util.Comparator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.TreeSet;
import java.util.function.Consumer;
import java.util.function.Predicate;

import org.jabref.logic.TypedBibEntry;
import org.jabref.model.database.BibDatabaseMode;
import org.jabref.model.entry.Author;
import org.jabref.model.entry.AuthorList;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.Month;
import org.jabref.model.entry.field.Field;
import org.jabref.model.entry.field.FieldFactory;
import org.jabref.model.entry.field.StandardField;
import org.jabref.model.entry.field.UnknownField;
import org.jabref.model.entry.types.EntryTypeFactory;
import org.jabref.model.strings.StringUtil;

import org.apache.xmpbox.DateConverter;
import org.apache.xmpbox.schema.DublinCoreSchema;
import org.apache.xmpbox.type.BadFieldValueException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class DublinCoreExtractor {

<span class="fc" id="L35">    private static final Logger LOGGER = LoggerFactory.getLogger(DublinCoreExtractor.class);</span>

    private final DublinCoreSchema dcSchema;
    private final XmpPreferences xmpPreferences;

    private final BibEntry bibEntry;

    /**
     * @param dcSchema      Metadata in DublinCore format.
     * @param resolvedEntry The BibEntry object, which is filled during metadata extraction.
     */
<span class="fc" id="L46">    public DublinCoreExtractor(DublinCoreSchema dcSchema, XmpPreferences xmpPreferences, BibEntry resolvedEntry) {</span>
<span class="fc" id="L47">        this.dcSchema = dcSchema;</span>
<span class="fc" id="L48">        this.xmpPreferences = xmpPreferences;</span>

<span class="fc" id="L50">        this.bibEntry = resolvedEntry;</span>
<span class="fc" id="L51">    }</span>

    /**
     * Editor in BibTex - Contributor in DublinCore
     */
    private void extractEditor() {
<span class="fc" id="L57">        List&lt;String&gt; contributors = dcSchema.getContributors();</span>
<span class="pc bpc" id="L58" title="3 of 4 branches missed.">        if ((contributors != null) &amp;&amp; !contributors.isEmpty()) {</span>
<span class="nc" id="L59">            bibEntry.setField(StandardField.EDITOR, String.join(&quot; and &quot;, contributors));</span>
        }
<span class="fc" id="L61">    }</span>

    /**
     * Author in BibTex - Creator in DublinCore
     */
    private void extractAuthor() {
<span class="fc" id="L67">        List&lt;String&gt; creators = dcSchema.getCreators();</span>
<span class="pc bpc" id="L68" title="2 of 4 branches missed.">        if ((creators != null) &amp;&amp; !creators.isEmpty()) {</span>
<span class="fc" id="L69">           bibEntry.setField(StandardField.AUTHOR, String.join(&quot; and &quot;, creators));</span>
        }
<span class="fc" id="L71">    }</span>

    /**
     * Year in BibTex - Date in DublinCore is only the year information, because dc interprets empty months as January.
     * Tries to extract the month as well. In JabRef the bibtex/month/value is prioritized. &lt;br/&gt; The problem is the
     * default value of the calendar, which is always January, also if there is no month information in the xmp metdata.
     * The idea is, to reject all information with YYYY-01-01. In cases, where xmp is written with JabRef the month
     * property filled with jan will override this behavior and no data is lost. In the cases, where xmp is written by
     * another service, the assumption is, that the 1st January is not a publication date at all.
     */
    private void extractYearAndMonth() {
<span class="fc" id="L82">        List&lt;String&gt; dates = dcSchema.getUnqualifiedSequenceValueList(&quot;date&quot;);</span>
<span class="pc bpc" id="L83" title="1 of 4 branches missed.">        if ((dates != null) &amp;&amp; !dates.isEmpty()) {</span>
<span class="fc" id="L84">            String date = dates.get(0).trim();</span>
<span class="fc" id="L85">            Calendar calender = null;</span>
            try {
<span class="fc" id="L87">                calender = DateConverter.toCalendar(date);</span>
<span class="nc" id="L88">            } catch (IOException ignored) {</span>
                // Ignored
<span class="fc" id="L90">            }</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">            if (calender != null) {</span>
<span class="fc" id="L92">                bibEntry.setField(StandardField.YEAR, String.valueOf(calender.get(Calendar.YEAR)));</span>
<span class="fc" id="L93">                int monthNumber = calender.get(Calendar.MONTH) + 1;</span>
                // not the 1st of January
<span class="pc bpc" id="L95" title="3 of 4 branches missed.">                if (!((monthNumber == 1) &amp;&amp; (calender.get(Calendar.DAY_OF_MONTH) == 1))) {</span>
<span class="fc" id="L96">                    Month.getMonthByNumber(monthNumber)</span>
<span class="fc" id="L97">                         .ifPresent(month -&gt; bibEntry.setMonth(month));</span>
                }
            }
        }
<span class="fc" id="L101">    }</span>

    /**
     * Abstract in BibTex - Description in DublinCore
     */
    private void extractAbstract() {
<span class="fc" id="L107">        String description = null;</span>
        try {
<span class="fc" id="L109">            description = dcSchema.getDescription();</span>
<span class="nc" id="L110">        } catch (BadFieldValueException e) {</span>
<span class="nc" id="L111">            LOGGER.warn(&quot;Could not get abstract, e&quot;);</span>
<span class="fc" id="L112">        }</span>
<span class="fc bfc" id="L113" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(description)) {</span>
<span class="fc" id="L114">            bibEntry.setField(StandardField.ABSTRACT, description);</span>
        }
<span class="fc" id="L116">    }</span>

    /**
     * DOI in BibTex - Identifier in DublinCore
     */
    private void extractDOI() {
<span class="fc" id="L122">        String identifier = dcSchema.getIdentifier();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(identifier)) {</span>
<span class="fc" id="L124">            bibEntry.setField(StandardField.DOI, identifier);</span>
        }
<span class="fc" id="L126">    }</span>

    /**
     * Publisher are equivalent in both formats (BibTex and DublinCore)
     */
    private void extractPublisher() {
<span class="fc" id="L132">        List&lt;String&gt; publishers = dcSchema.getPublishers();</span>
<span class="pc bpc" id="L133" title="1 of 4 branches missed.">        if ((publishers != null) &amp;&amp; !publishers.isEmpty()) {</span>
<span class="fc" id="L134">            bibEntry.setField(StandardField.PUBLISHER, String.join(&quot; and &quot;, publishers));</span>
        }
<span class="fc" id="L136">    }</span>

    /**
     * This method sets all fields, which are custom in BibTeX and therefore supported by JabRef, but which are not
     * included in the DublinCore format.
     * &lt;p&gt;
     * The relation attribute of DublinCore is abused to insert these custom fields.
     */
    private void extractBibTexFields() {
<span class="fc" id="L145">        Predicate&lt;String&gt; isBibTeXElement = s -&gt; s.startsWith(&quot;bibtex/&quot;);</span>
<span class="fc" id="L146">        Consumer&lt;String&gt; splitBibTeXElement = s -&gt; {</span>
            // the default pattern is bibtex/key/value, but some fields contains url etc.
            // so the value property contains additional slashes, which makes the usage of
            // String#split complicated.
<span class="fc" id="L150">            String temp = s.substring(&quot;bibtex/&quot;.length());</span>
<span class="fc" id="L151">            int i = temp.indexOf('/');</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">            if (i != -1) {</span>
<span class="fc" id="L153">                Field key = FieldFactory.parseField(temp.substring(0, i));</span>
<span class="fc" id="L154">                String value = temp.substring(i + 1);</span>
<span class="fc" id="L155">                bibEntry.setField(key, value);</span>

                // only for month field - override value
                // workaround, because the date value of the xmp component of pdf box is corrupted
                // see also DublinCoreExtractor#extractYearAndMonth
<span class="fc bfc" id="L160" title="All 2 branches covered.">                if (StandardField.MONTH.equals(key)) {</span>
<span class="fc" id="L161">                    Optional&lt;Month&gt; parsedMonth = Month.parse(value);</span>
<span class="fc" id="L162">                    parsedMonth.ifPresent(bibEntry::setMonth);</span>
                }
            }
<span class="fc" id="L165">        };</span>
<span class="fc" id="L166">        List&lt;String&gt; relationships = dcSchema.getRelations();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (relationships != null) {</span>
<span class="fc" id="L168">            relationships.stream()</span>
<span class="fc" id="L169">                         .filter(isBibTeXElement)</span>
<span class="fc" id="L170">                         .forEach(splitBibTeXElement);</span>
        }
<span class="fc" id="L172">    }</span>

    /**
     * Rights are equivalent in both formats (BibTex and DublinCore)
     */
    private void extractRights() {
<span class="fc" id="L178">        String rights = null;</span>
        try {
<span class="fc" id="L180">            rights = dcSchema.getRights();</span>
<span class="nc" id="L181">        } catch (BadFieldValueException e) {</span>
<span class="nc" id="L182">           LOGGER.warn(&quot;Could not extract rights&quot;, e);</span>
<span class="fc" id="L183">        }</span>
<span class="pc bpc" id="L184" title="1 of 2 branches missed.">        if (!StringUtil.isNullOrEmpty(rights)) {</span>
<span class="nc" id="L185">            bibEntry.setField(new UnknownField(&quot;rights&quot;), rights);</span>
        }
<span class="fc" id="L187">    }</span>

    /**
     * Source is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractSource() {
<span class="fc" id="L193">        String source = dcSchema.getSource();</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">        if (!StringUtil.isNullOrEmpty(source)) {</span>
<span class="nc" id="L195">            bibEntry.setField(new UnknownField(&quot;source&quot;), source);</span>
        }
<span class="fc" id="L197">    }</span>

    /**
     * Keywords in BibTex - Subjects in DublinCore
     */
    private void extractSubject() {
<span class="fc" id="L203">        List&lt;String&gt; subjects = dcSchema.getSubjects();</span>
<span class="pc bpc" id="L204" title="1 of 4 branches missed.">        if ((subjects != null) &amp;&amp; !subjects.isEmpty()) {</span>
<span class="fc" id="L205">            bibEntry.addKeywords(subjects, xmpPreferences.getKeywordSeparator());</span>
        }
<span class="fc" id="L207">    }</span>

    /**
     * Title is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractTitle() {
<span class="fc" id="L213">        String title = null;</span>
        try {
<span class="fc" id="L215">            title = dcSchema.getTitle();</span>
<span class="nc" id="L216">        } catch (BadFieldValueException e) {</span>
<span class="nc" id="L217">            LOGGER.warn(&quot;Could not extract title&quot;, e);</span>
<span class="fc" id="L218">        }</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">        if (!StringUtil.isNullOrEmpty(title)) {</span>
<span class="fc" id="L220">            bibEntry.setField(StandardField.TITLE, title);</span>
        }
<span class="fc" id="L222">    }</span>

    /**
     * Type is equivalent in both formats (BibTex and DublinCore)
     */
    private void extractType() {
<span class="fc" id="L228">        List&lt;String&gt; types = dcSchema.getTypes();</span>
<span class="pc bpc" id="L229" title="1 of 4 branches missed.">        if ((types != null) &amp;&amp; !types.isEmpty()) {</span>
<span class="fc" id="L230">            String type = types.get(0);</span>
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">            if (!StringUtil.isNullOrEmpty(type)) {</span>
<span class="fc" id="L232">                bibEntry.setType(EntryTypeFactory.parse(type));</span>
            }
        }
<span class="fc" id="L235">    }</span>

    /**
     * Helper function for retrieving a BibEntry from the DublinCore metadata in a PDF file.
     * &lt;p&gt;
     * To understand how to get hold of a DublinCore have a look in the test cases for XMPUtil.
     * &lt;p&gt;
     * The BibEntry is build by mapping individual fields in the dublin core (like creator, title, subject) to fields in
     * a bibtex bibEntry. In case special &quot;bibtex/&quot; entries are contained, the normal dublin core fields take
     * precedence. For instance, the dublin core date takes precedence over bibtex/month.
     *
     * @return The bibEntry extracted from the document information.
     */
    public Optional&lt;BibEntry&gt; extractBibtexEntry() {
        // first extract &quot;bibtex/&quot; entries
<span class="fc" id="L250">        this.extractBibTexFields();</span>

        // then extract all &quot;standard&quot; dublin core entries
<span class="fc" id="L253">        this.extractEditor();</span>
<span class="fc" id="L254">        this.extractAuthor();</span>
<span class="fc" id="L255">        this.extractYearAndMonth();</span>
<span class="fc" id="L256">        this.extractAbstract();</span>
<span class="fc" id="L257">        this.extractDOI();</span>
<span class="fc" id="L258">        this.extractPublisher();</span>
<span class="fc" id="L259">        this.extractRights();</span>
<span class="fc" id="L260">        this.extractSource();</span>
<span class="fc" id="L261">        this.extractSubject();</span>
<span class="fc" id="L262">        this.extractTitle();</span>
<span class="fc" id="L263">        this.extractType();</span>

        // we pass a new BibEntry in the constructor which is never empty as it already consists of &quot;@misc&quot;
<span class="fc bfc" id="L266" title="All 2 branches covered.">        if (bibEntry.getFieldMap().isEmpty()) {</span>
<span class="fc" id="L267">            return Optional.empty();</span>
        }
<span class="fc" id="L269">        return Optional.of(bibEntry);</span>
    }

    /**
     * Bibtex-Fields used: editor, Field: 'dc:contributor'
     *
     * @param authors
     */
    private void fillContributor(String authors) {
<span class="nc" id="L278">        AuthorList list = AuthorList.parse(authors);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">        for (Author author : list.getAuthors()) {</span>
<span class="nc" id="L280">            dcSchema.addContributor(author.getFirstLast(false));</span>
<span class="nc" id="L281">        }</span>
<span class="nc" id="L282">    }</span>

    /**
     * Bibtex-Fields used: author, Field: 'dc:creator'
     *
     * @param creators
     */
    private void fillCreator(String creators) {
<span class="fc" id="L290">        AuthorList list = AuthorList.parse(creators);</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">        for (Author author : list.getAuthors()) {</span>
<span class="fc" id="L293">            dcSchema.addCreator(author.getFirstLast(false));</span>
<span class="fc" id="L294">        }</span>
<span class="fc" id="L295">    }</span>

    /**
     * Bibtex-Fields used: year, month, Field: 'dc:date'
     */
    private void fillDate() {
<span class="nc" id="L301">        bibEntry.getFieldOrAlias(StandardField.DATE)</span>
<span class="nc" id="L302">                .ifPresent(publicationDate -&gt; dcSchema.addUnqualifiedSequenceValue(&quot;date&quot;, publicationDate));</span>
<span class="nc" id="L303">    }</span>

    /**
     * Bibtex-Fields used: abstract, Field: 'dc:description'
     *
     * @param description
     */
    private void fillDescription(String description) {
<span class="fc" id="L311">        dcSchema.setDescription(description);</span>
<span class="fc" id="L312">    }</span>

    /**
     * Bibtex-Fields used: doi, Field: 'dc:identifier'
     *
     * @param identifier
     */
    private void fillIdentifier(String identifier) {
<span class="fc" id="L320">        dcSchema.setIdentifier(identifier);</span>
<span class="fc" id="L321">    }</span>

    /**
     * Bibtex-Fields used: publisher, Field: dc:publisher
     *
     * @param publisher
     */
    private void fillPublisher(String publisher) {
<span class="fc" id="L329">        dcSchema.addPublisher(publisher);</span>
<span class="fc" id="L330">    }</span>

    /**
     * Bibtex-Fields used: keywords, Field: 'dc:subject'
     *
     * @param value
     */
    private void fillKeywords(String value) {
<span class="fc" id="L338">        String[] keywords = value.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        for (String keyword : keywords) {</span>
<span class="fc" id="L340">            dcSchema.addSubject(keyword.trim());</span>
        }
<span class="fc" id="L342">    }</span>

    /**
     * Bibtex-Fields used: title, Field: 'dc:title'
     *
     * @param title
     */
    private void fillTitle(String title) {
<span class="fc" id="L350">        dcSchema.setTitle(title);</span>
<span class="fc" id="L351">    }</span>

    /**
     * All others (+ citation key) get packaged in the relation attribute
     *
     * @param field Key of the metadata attribute
     * @param value Value of the metadata attribute
     */
    private void fillCustomField(Field field, String value) {
<span class="fc" id="L360">        dcSchema.addRelation(&quot;bibtex/&quot; + field.getName() + '/' + value);</span>
<span class="fc" id="L361">    }</span>

    public void fillDublinCoreSchema() {
        // Query privacy filter settings
<span class="fc" id="L365">        boolean useXmpPrivacyFilter = xmpPreferences.shouldUseXmpPrivacyFilter();</span>

<span class="fc" id="L367">        Set&lt;Entry&lt;Field, String&gt;&gt; fieldValues = new TreeSet&lt;&gt;(Comparator.comparing(fieldStringEntry -&gt; fieldStringEntry.getKey().getName()));</span>
<span class="fc" id="L368">        fieldValues.addAll(bibEntry.getFieldMap().entrySet());</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">        for (Entry&lt;Field, String&gt; field : fieldValues) {</span>
<span class="pc bpc" id="L370" title="1 of 4 branches missed.">            if (useXmpPrivacyFilter &amp;&amp; xmpPreferences.getXmpPrivacyFilter().contains(field.getKey())) {</span>
<span class="fc" id="L371">                continue;</span>
            }

<span class="pc bpc" id="L374" title="1 of 2 branches missed.">            if (StandardField.EDITOR.equals(field.getKey())) {</span>
<span class="nc" id="L375">                this.fillContributor(field.getValue());</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">            } else if (StandardField.AUTHOR.equals(field.getKey())) {</span>
<span class="fc" id="L377">                this.fillCreator(field.getValue());</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">            } else if (StandardField.YEAR.equals(field.getKey())) {</span>
<span class="nc" id="L379">                this.fillDate();</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            } else if (StandardField.ABSTRACT.equals(field.getKey())) {</span>
<span class="fc" id="L381">                this.fillDescription(field.getValue());</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">            } else if (StandardField.DOI.equals(field.getKey())) {</span>
<span class="fc" id="L383">                this.fillIdentifier(field.getValue());</span>
<span class="fc bfc" id="L384" title="All 2 branches covered.">            } else if (StandardField.PUBLISHER.equals(field.getKey())) {</span>
<span class="fc" id="L385">                this.fillPublisher(field.getValue());</span>
<span class="fc bfc" id="L386" title="All 2 branches covered.">            } else if (StandardField.KEYWORDS.equals(field.getKey())) {</span>
<span class="fc" id="L387">                this.fillKeywords(field.getValue());</span>
<span class="fc bfc" id="L388" title="All 2 branches covered.">            } else if (StandardField.TITLE.equals(field.getKey())) {</span>
<span class="fc" id="L389">                this.fillTitle(field.getValue());</span>
            } else {
<span class="fc" id="L391">                this.fillCustomField(field.getKey(), field.getValue());</span>
            }
<span class="fc" id="L393">        }</span>

<span class="fc" id="L395">        dcSchema.setFormat(&quot;application/pdf&quot;);</span>

        // Bibtex-Fields used: entrytype, Field: 'dc:type'
<span class="fc" id="L398">        TypedBibEntry typedEntry = new TypedBibEntry(bibEntry, BibDatabaseMode.BIBTEX);</span>
<span class="fc" id="L399">        String o = typedEntry.getTypeForDisplay();</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">        if (!o.isEmpty()) {</span>
<span class="fc" id="L401">            dcSchema.addType(o);</span>
        }
<span class="fc" id="L403">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>