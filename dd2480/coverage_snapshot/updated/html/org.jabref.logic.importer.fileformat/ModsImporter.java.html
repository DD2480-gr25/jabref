<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ModsImporter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">JabRef</a> &gt; <a href="index.source.html" class="el_package">org.jabref.logic.importer.fileformat</a> &gt; <span class="el_source">ModsImporter.java</span></div><h1>ModsImporter.java</h1><pre class="source lang-java linenums">package org.jabref.logic.importer.fileformat;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.jabref.logic.importer.ImportFormatPreferences;
import org.jabref.logic.importer.Importer;
import org.jabref.logic.importer.ParseException;
import org.jabref.logic.importer.Parser;
import org.jabref.logic.importer.ParserResult;
import org.jabref.logic.importer.fileformat.mods.AbstractDefinition;
import org.jabref.logic.importer.fileformat.mods.DateDefinition;
import org.jabref.logic.importer.fileformat.mods.DetailDefinition;
import org.jabref.logic.importer.fileformat.mods.ExtentDefinition;
import org.jabref.logic.importer.fileformat.mods.GenreDefinition;
import org.jabref.logic.importer.fileformat.mods.HierarchicalGeographicDefinition;
import org.jabref.logic.importer.fileformat.mods.IdentifierDefinition;
import org.jabref.logic.importer.fileformat.mods.IssuanceDefinition;
import org.jabref.logic.importer.fileformat.mods.LanguageDefinition;
import org.jabref.logic.importer.fileformat.mods.LanguageTermDefinition;
import org.jabref.logic.importer.fileformat.mods.LocationDefinition;
import org.jabref.logic.importer.fileformat.mods.ModsCollectionDefinition;
import org.jabref.logic.importer.fileformat.mods.ModsDefinition;
import org.jabref.logic.importer.fileformat.mods.NameDefinition;
import org.jabref.logic.importer.fileformat.mods.NamePartDefinition;
import org.jabref.logic.importer.fileformat.mods.NoteDefinition;
import org.jabref.logic.importer.fileformat.mods.OriginInfoDefinition;
import org.jabref.logic.importer.fileformat.mods.PartDefinition;
import org.jabref.logic.importer.fileformat.mods.PhysicalLocationDefinition;
import org.jabref.logic.importer.fileformat.mods.PlaceDefinition;
import org.jabref.logic.importer.fileformat.mods.PlaceTermDefinition;
import org.jabref.logic.importer.fileformat.mods.RecordInfoDefinition;
import org.jabref.logic.importer.fileformat.mods.RelatedItemDefinition;
import org.jabref.logic.importer.fileformat.mods.StringPlusLanguage;
import org.jabref.logic.importer.fileformat.mods.StringPlusLanguagePlusAuthority;
import org.jabref.logic.importer.fileformat.mods.StringPlusLanguagePlusSupplied;
import org.jabref.logic.importer.fileformat.mods.SubjectDefinition;
import org.jabref.logic.importer.fileformat.mods.TitleInfoDefinition;
import org.jabref.logic.importer.fileformat.mods.UrlDefinition;
import org.jabref.logic.util.StandardFileType;
import org.jabref.model.entry.BibEntry;
import org.jabref.model.entry.field.Field;
import org.jabref.model.entry.field.FieldFactory;
import org.jabref.model.entry.field.StandardField;
import org.jabref.model.entry.field.UnknownField;
import org.jabref.model.entry.types.EntryTypeFactory;

import com.google.common.base.Joiner;
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBElement;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Unmarshaller;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Importer for the MODS format.&lt;br&gt;
 * More details about the format can be found here &lt;a href=&quot;http://www.loc.gov/standards/mods/&quot;&gt;http://www.loc.gov/standards/mods/&lt;/a&gt;. &lt;br&gt;
 * The newest xml schema can also be found here &lt;a href=&quot;www.loc.gov/standards/mods/mods-schemas.html.&quot;&gt;www.loc.gov/standards/mods/mods-schemas.html.&lt;/a&gt;.
 */
public class ModsImporter extends Importer implements Parser {

<span class="fc" id="L75">    private static final Logger LOGGER = LoggerFactory.getLogger(ModsImporter.class);</span>
<span class="fc" id="L76">    private static final Pattern MODS_PATTERN = Pattern.compile(&quot;&lt;mods .*&gt;&quot;);</span>

    private final String keywordSeparator;

    private JAXBContext context;

<span class="fc" id="L82">    public ModsImporter(ImportFormatPreferences importFormatPreferences) {</span>
<span class="fc" id="L83">        keywordSeparator = importFormatPreferences.getKeywordSeparator() + &quot; &quot;;</span>
<span class="fc" id="L84">    }</span>

    @Override
    public boolean isRecognizedFormat(BufferedReader input) throws IOException {
<span class="fc" id="L88">        return input.lines().anyMatch(line -&gt; MODS_PATTERN.matcher(line).find());</span>
    }

    @Override
    public ParserResult importDatabase(BufferedReader input) throws IOException {
<span class="fc" id="L93">        Objects.requireNonNull(input);</span>

<span class="fc" id="L95">        List&lt;BibEntry&gt; bibItems = new ArrayList&lt;&gt;();</span>

        try {
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">            if (context == null) {</span>
<span class="fc" id="L99">                context = JAXBContext.newInstance(&quot;org.jabref.logic.importer.fileformat.mods&quot;);</span>
            }
<span class="fc" id="L101">            Unmarshaller unmarshaller = context.createUnmarshaller();</span>

            // The unmarshalled object is a jaxbElement.
<span class="fc" id="L104">            JAXBElement&lt;?&gt; unmarshalledObject = (JAXBElement&lt;?&gt;) unmarshaller.unmarshal(input);</span>

<span class="fc" id="L106">            Optional&lt;ModsCollectionDefinition&gt; collection = getElement(unmarshalledObject.getValue(),</span>
                    ModsCollectionDefinition.class);
<span class="fc" id="L108">            Optional&lt;ModsDefinition&gt; mods = getElement(unmarshalledObject.getValue(), ModsDefinition.class);</span>

<span class="fc bfc" id="L110" title="All 2 branches covered.">            if (collection.isPresent()) {</span>
<span class="fc" id="L111">                List&lt;ModsDefinition&gt; modsDefinitions = collection.get().getMods();</span>
<span class="fc" id="L112">                parseModsCollection(bibItems, modsDefinitions);</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            } else if (mods.isPresent()) {</span>
<span class="fc" id="L114">                ModsDefinition modsDefinition = mods.get();</span>
<span class="fc" id="L115">                parseMods(bibItems, modsDefinition);</span>
<span class="fc" id="L116">            } else {</span>
<span class="nc" id="L117">                LOGGER.warn(&quot;Not expected root element found&quot;);</span>
            }
<span class="fc" id="L119">        } catch (JAXBException e) {</span>
<span class="fc" id="L120">            LOGGER.debug(&quot;could not parse document&quot;, e);</span>
<span class="fc" id="L121">            return ParserResult.fromError(e);</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">        return new ParserResult(bibItems);</span>
    }

    private void parseModsCollection(List&lt;BibEntry&gt; bibItems, List&lt;ModsDefinition&gt; mods) {
<span class="fc bfc" id="L127" title="All 2 branches covered.">        for (ModsDefinition modsDefinition : mods) {</span>
<span class="fc" id="L128">            parseMods(bibItems, modsDefinition);</span>
<span class="fc" id="L129">        }</span>
<span class="fc" id="L130">    }</span>

    private void parseMods(List&lt;BibEntry&gt; bibItems, ModsDefinition modsDefinition) {
<span class="fc" id="L133">        BibEntry entry = new BibEntry();</span>
<span class="fc" id="L134">        Map&lt;Field, String&gt; fields = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L135" title="All 2 branches covered.">        if (modsDefinition.getID() != null) {</span>
<span class="fc" id="L136">            entry.setCitationKey(modsDefinition.getID());</span>
        }
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">        if (modsDefinition.getModsGroup() != null) {</span>
<span class="fc" id="L139">            parseModsGroup(fields, modsDefinition.getModsGroup(), entry);</span>
        }
<span class="fc" id="L141">        entry.setField(fields);</span>
<span class="fc" id="L142">        bibItems.add(entry);</span>
<span class="fc" id="L143">    }</span>

    private void parseModsGroup(Map&lt;Field, String&gt; fields, List&lt;Object&gt; modsGroup, BibEntry entry) {
<span class="fc" id="L146">        List&lt;String&gt; keywords = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L147">        List&lt;String&gt; authors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L148">        List&lt;String&gt; notes = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        for (Object groupElement : modsGroup) {</span>

            // Get the element. Only one of the elements should be not an empty optional.
<span class="fc" id="L153">            Optional&lt;AbstractDefinition&gt; abstractDefinition = getElement(groupElement, AbstractDefinition.class);</span>
<span class="fc" id="L154">            Optional&lt;GenreDefinition&gt; genreDefinition = getElement(groupElement, GenreDefinition.class);</span>
<span class="fc" id="L155">            Optional&lt;LanguageDefinition&gt; languageDefinition = getElement(groupElement, LanguageDefinition.class);</span>
<span class="fc" id="L156">            Optional&lt;LocationDefinition&gt; locationDefinition = getElement(groupElement, LocationDefinition.class);</span>
<span class="fc" id="L157">            Optional&lt;NameDefinition&gt; nameDefinition = getElement(groupElement, NameDefinition.class);</span>
<span class="fc" id="L158">            Optional&lt;OriginInfoDefinition&gt; originInfoDefinition = getElement(groupElement, OriginInfoDefinition.class);</span>
<span class="fc" id="L159">            Optional&lt;RecordInfoDefinition&gt; recordInfoDefinition = getElement(groupElement, RecordInfoDefinition.class);</span>
<span class="fc" id="L160">            Optional&lt;NoteDefinition&gt; noteDefinition = getElement(groupElement, NoteDefinition.class);</span>
<span class="fc" id="L161">            Optional&lt;RelatedItemDefinition&gt; relatedItemDefinition = getElement(groupElement,</span>
                    RelatedItemDefinition.class);
<span class="fc" id="L163">            Optional&lt;SubjectDefinition&gt; subjectDefinition = getElement(groupElement, SubjectDefinition.class);</span>
<span class="fc" id="L164">            Optional&lt;IdentifierDefinition&gt; identifierDefinition = getElement(groupElement, IdentifierDefinition.class);</span>
<span class="fc" id="L165">            Optional&lt;TitleInfoDefinition&gt; titleInfoDefinition = getElement(groupElement, TitleInfoDefinition.class);</span>

            // Now parse the information if the element is present
<span class="fc" id="L168">            abstractDefinition</span>
<span class="fc" id="L169">                    .ifPresent(abstractDef -&gt; putIfValueNotNull(fields, StandardField.ABSTRACT, abstractDef.getValue()));</span>

<span class="fc" id="L171">            genreDefinition.ifPresent(genre -&gt; entry.setType(EntryTypeFactory.parse(genre.getValue())));</span>

<span class="fc" id="L173">            languageDefinition.ifPresent(</span>
<span class="fc" id="L174">                    languageDef -&gt; languageDef.getLanguageTerm().stream().map(LanguageTermDefinition::getValue)</span>
<span class="fc" id="L175">                                              .forEach(language -&gt; putIfValueNotNull(fields, StandardField.LANGUAGE, language)));</span>

<span class="fc" id="L177">            locationDefinition.ifPresent(location -&gt; parseLocationAndUrl(fields, location));</span>

<span class="fc" id="L179">            nameDefinition.ifPresent(name -&gt; handleAuthorsInNamePart(name, authors, fields));</span>

<span class="fc" id="L181">            originInfoDefinition.ifPresent(originInfo -&gt; originInfo</span>
<span class="fc" id="L182">                    .getPlaceOrPublisherOrDateIssued().stream()</span>
<span class="fc" id="L183">                    .forEach(element -&gt; putPlaceOrPublisherOrDate(fields, element.getName().getLocalPart(),</span>
<span class="fc" id="L184">                            element.getValue())));</span>

<span class="fc" id="L186">            recordInfoDefinition.ifPresent(recordInfo -&gt; parseRecordInfo(fields, recordInfo));</span>

<span class="fc" id="L188">            noteDefinition.ifPresent(note -&gt; notes.add(note.getValue()));</span>

<span class="fc" id="L190">            relatedItemDefinition.ifPresent(relatedItem -&gt; parseRelatedModsGroup(fields, relatedItem.getModsGroup()));</span>

<span class="fc" id="L192">            subjectDefinition</span>
<span class="fc" id="L193">                    .ifPresent(subject -&gt; parseTopic(fields, subject.getTopicOrGeographicOrTemporal(), keywords));</span>

<span class="fc" id="L195">            identifierDefinition.ifPresent(identifier -&gt; parseIdentifier(fields, identifier, entry));</span>

<span class="fc" id="L197">            titleInfoDefinition.ifPresent(titleInfo -&gt; parseTitle(fields, titleInfo.getTitleOrSubTitleOrPartNumber()));</span>

<span class="fc" id="L199">        }</span>

        // The element subject can appear more than one time, that's why the keywords has to be put out of the for loop
<span class="fc" id="L202">        putIfListIsNotEmpty(fields, keywords, StandardField.KEYWORDS, this.keywordSeparator);</span>
        // same goes for authors and notes
<span class="fc" id="L204">        putIfListIsNotEmpty(fields, authors, StandardField.AUTHOR, &quot; and &quot;);</span>
<span class="fc" id="L205">        putIfListIsNotEmpty(fields, notes, StandardField.NOTE, &quot;, &quot;);</span>

<span class="fc" id="L207">    }</span>

    private void parseTitle(Map&lt;Field, String&gt; fields, List&lt;Object&gt; titleOrSubTitleOrPartNumber) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        for (Object object : titleOrSubTitleOrPartNumber) {</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            if (object instanceof JAXBElement) {</span>
                @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L213">                JAXBElement&lt;StringPlusLanguage&gt; element = (JAXBElement&lt;StringPlusLanguage&gt;) object;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                if (&quot;title&quot;.equals(element.getName().getLocalPart())) {</span>
<span class="fc" id="L215">                    StringPlusLanguage title = element.getValue();</span>
<span class="fc" id="L216">                    fields.put(StandardField.TITLE, title.getValue());</span>
                }
            }
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">    }</span>

    private void parseIdentifier(Map&lt;Field, String&gt; fields, IdentifierDefinition identifier, BibEntry entry) {
<span class="fc" id="L223">        String type = identifier.getType();</span>
<span class="fc bfc" id="L224" title="All 4 branches covered.">        if (&quot;citekey&quot;.equals(type) &amp;&amp; !entry.getCitationKey().isPresent()) {</span>
<span class="fc" id="L225">            entry.setCitationKey(identifier.getValue());</span>
<span class="fc bfc" id="L226" title="All 4 branches covered.">        } else if (!&quot;local&quot;.equals(type) &amp;&amp; !&quot;citekey&quot;.equals(type)) {</span>
            // put all identifiers (doi, issn, isbn,...) except of local and citekey
<span class="fc" id="L228">            putIfValueNotNull(fields, FieldFactory.parseField(identifier.getType()), identifier.getValue());</span>
        }
<span class="fc" id="L230">    }</span>

    private void parseTopic(Map&lt;Field, String&gt; fields, List&lt;JAXBElement&lt;?&gt;&gt; topicOrGeographicOrTemporal,
                            List&lt;String&gt; keywords) {
<span class="fc bfc" id="L234" title="All 2 branches covered.">        for (JAXBElement&lt;?&gt; jaxbElement : topicOrGeographicOrTemporal) {</span>
<span class="fc" id="L235">            Object value = jaxbElement.getValue();</span>
<span class="fc" id="L236">            String elementName = jaxbElement.getName().getLocalPart();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (value instanceof HierarchicalGeographicDefinition) {</span>
<span class="fc" id="L238">                HierarchicalGeographicDefinition hierarchichalGeographic = (HierarchicalGeographicDefinition) value;</span>
<span class="fc" id="L239">                parseGeographicInformation(fields, hierarchichalGeographic);</span>
<span class="pc bpc" id="L240" title="2 of 4 branches missed.">            } else if ((value instanceof StringPlusLanguagePlusAuthority) &amp;&amp; &quot;topic&quot;.equals(elementName)) {</span>
<span class="fc" id="L241">                StringPlusLanguagePlusAuthority topic = (StringPlusLanguagePlusAuthority) value;</span>
<span class="fc" id="L242">                keywords.add(topic.getValue().trim());</span>
            }
<span class="fc" id="L244">        }</span>
<span class="fc" id="L245">    }</span>

    /**
     * Returns an Optional which contains an instance of the given class, if the given element can be cast to this class.
     * If the element cannot be cast to the given class, then an empty optional will be returned.
     *
     * @param groupElement The element that should be cast
     * @param clazz        The class to which groupElement should be cast
     * @return An Optional, that contains the groupElement as instance of clazz, if groupElement can be cast to clazz.
     * An empty Optional, if groupElement cannot be cast to clazz
     */
    private &lt;T&gt; Optional&lt;T&gt; getElement(Object groupElement, Class&lt;T&gt; clazz) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (clazz.isAssignableFrom(groupElement.getClass())) {</span>
<span class="fc" id="L258">            return Optional.of(clazz.cast(groupElement));</span>
        }
<span class="fc" id="L260">        return Optional.empty();</span>
    }

    private void parseGeographicInformation(Map&lt;Field, String&gt; fields,
                                            HierarchicalGeographicDefinition hierarchichalGeographic) {
<span class="fc" id="L265">        List&lt;JAXBElement&lt;? extends StringPlusLanguage&gt;&gt; areaOrContinentOrCountry = hierarchichalGeographic</span>
<span class="fc" id="L266">                .getExtraTerrestrialAreaOrContinentOrCountry();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (JAXBElement&lt;? extends StringPlusLanguage&gt; element : areaOrContinentOrCountry) {</span>
<span class="fc" id="L268">            String localName = element.getName().getLocalPart();</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">            if (&quot;city&quot;.equals(localName)) {</span>
<span class="fc" id="L270">                StringPlusLanguage city = element.getValue();</span>
<span class="fc" id="L271">                putIfValueNotNull(fields, new UnknownField(&quot;city&quot;), city.getValue());</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">            } else if (&quot;country&quot;.equals(localName)) {</span>
<span class="fc" id="L273">                StringPlusLanguage country = element.getValue();</span>
<span class="fc" id="L274">                putIfValueNotNull(fields, new UnknownField(&quot;country&quot;), country.getValue());</span>
            }
<span class="fc" id="L276">        }</span>
<span class="fc" id="L277">    }</span>

    private void parseLocationAndUrl(Map&lt;Field, String&gt; fields, LocationDefinition locationDefinition) {
<span class="fc" id="L280">        List&lt;String&gt; locations = locationDefinition.getPhysicalLocation().stream()</span>
<span class="fc" id="L281">                                                   .map(PhysicalLocationDefinition::getValue).collect(Collectors.toList());</span>
<span class="fc" id="L282">        putIfListIsNotEmpty(fields, locations, StandardField.LOCATION, &quot;, &quot;);</span>

<span class="fc" id="L284">        List&lt;String&gt; urls = locationDefinition.getUrl().stream().map(UrlDefinition::getValue)</span>
<span class="fc" id="L285">                                              .collect(Collectors.toList());</span>
<span class="fc" id="L286">        putIfListIsNotEmpty(fields, urls, StandardField.URL, &quot;, &quot;);</span>
<span class="fc" id="L287">    }</span>

    private void parseRecordInfo(Map&lt;Field, String&gt; fields, RecordInfoDefinition recordInfo) {
<span class="fc" id="L290">        List&lt;JAXBElement&lt;?&gt;&gt; recordContent = recordInfo.getRecordContentSourceOrRecordCreationDateOrRecordChangeDate();</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">        for (JAXBElement&lt;?&gt; jaxbElement : recordContent) {</span>
<span class="fc" id="L292">            Object value = jaxbElement.getValue();</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">            if (value instanceof StringPlusLanguagePlusAuthority) {</span>
<span class="fc" id="L294">                StringPlusLanguagePlusAuthority source = (StringPlusLanguagePlusAuthority) value;</span>
<span class="fc" id="L295">                putIfValueNotNull(fields, new UnknownField(&quot;source&quot;), source.getValue());</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">            } else if (value instanceof LanguageDefinition) {</span>
<span class="fc" id="L297">                LanguageDefinition language = (LanguageDefinition) value;</span>
<span class="fc" id="L298">                List&lt;LanguageTermDefinition&gt; languageTerms = language.getLanguageTerm();</span>
<span class="fc" id="L299">                List&lt;String&gt; languages = languageTerms.stream().map(LanguageTermDefinition::getValue)</span>
<span class="fc" id="L300">                                                      .collect(Collectors.toList());</span>
<span class="fc" id="L301">                putIfListIsNotEmpty(fields, languages, StandardField.LANGUAGE, &quot;, &quot;);</span>
            }
<span class="fc" id="L303">        }</span>
<span class="fc" id="L304">    }</span>

    /**
     * Puts the Information from the RelatedModsGroup. It has the same elements like the ModsGroup.
     * But Informations like volume, issue and the pages appear here instead of in the ModsGroup.
     * Also if there appears a title field, then this indicates that is the name of journal which the article belongs to.
     */
    private void parseRelatedModsGroup(Map&lt;Field, String&gt; fields, List&lt;Object&gt; relatedModsGroup) {
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (Object groupElement : relatedModsGroup) {</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">            if (groupElement instanceof PartDefinition) {</span>
<span class="fc" id="L314">                PartDefinition part = (PartDefinition) groupElement;</span>
<span class="fc" id="L315">                List&lt;Object&gt; detailOrExtentOrDate = part.getDetailOrExtentOrDate();</span>
<span class="fc bfc" id="L316" title="All 2 branches covered.">                for (Object object : detailOrExtentOrDate) {</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">                    if (object instanceof DetailDefinition) {</span>
<span class="fc" id="L318">                        DetailDefinition detail = (DetailDefinition) object;</span>
<span class="fc" id="L319">                        List&lt;JAXBElement&lt;StringPlusLanguage&gt;&gt; numberOrCaptionOrTitle = detail</span>
<span class="fc" id="L320">                                .getNumberOrCaptionOrTitle();</span>

                        // In the for loop should only be the value of the element that belongs to the detail not be null
<span class="fc bfc" id="L323" title="All 2 branches covered.">                        for (JAXBElement&lt;StringPlusLanguage&gt; jaxbElement : numberOrCaptionOrTitle) {</span>
<span class="fc" id="L324">                            StringPlusLanguage value = jaxbElement.getValue();</span>
                            // put details like volume, issue,...
<span class="fc" id="L326">                            putIfValueNotNull(fields, FieldFactory.parseField(detail.getType()), value.getValue());</span>
<span class="fc" id="L327">                        }</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">                    } else if (object instanceof ExtentDefinition) {</span>
<span class="fc" id="L329">                        ExtentDefinition extentDefinition = (ExtentDefinition) object;</span>
<span class="fc" id="L330">                        putPageInformation(extentDefinition, fields);</span>
                    }
<span class="fc" id="L332">                }</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">            } else if (groupElement instanceof TitleInfoDefinition) {</span>
<span class="fc" id="L334">                TitleInfoDefinition titleInfo = (TitleInfoDefinition) groupElement;</span>
<span class="fc" id="L335">                List&lt;Object&gt; titleOrSubTitleOrPartNumber = titleInfo.getTitleOrSubTitleOrPartNumber();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">                for (Object object : titleOrSubTitleOrPartNumber) {</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">                    if (object instanceof JAXBElement) {</span>
                        @SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L339">                        JAXBElement&lt;StringPlusLanguage&gt; element = (JAXBElement&lt;StringPlusLanguage&gt;) object;</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                        if (&quot;title&quot;.equals(element.getName().getLocalPart())) {</span>
<span class="fc" id="L341">                            StringPlusLanguage journal = element.getValue();</span>
<span class="fc" id="L342">                            fields.put(StandardField.JOURNAL, journal.getValue());</span>
                        }
                    }
<span class="fc" id="L345">                }</span>
            }
<span class="fc" id="L347">        }</span>
<span class="fc" id="L348">    }</span>

    private void putPageInformation(ExtentDefinition extentDefinition, Map&lt;Field, String&gt; fields) {
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (extentDefinition.getTotal() != null) {</span>
<span class="fc" id="L352">            putIfValueNotNull(fields, StandardField.PAGES, String.valueOf(extentDefinition.getTotal()));</span>
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">        } else if (extentDefinition.getStart() != null) {</span>
<span class="fc" id="L354">            putIfValueNotNull(fields, StandardField.PAGES, extentDefinition.getStart().getValue());</span>
<span class="pc bpc" id="L355" title="1 of 2 branches missed.">            if (extentDefinition.getEnd() != null) {</span>
<span class="fc" id="L356">                String endPage = extentDefinition.getEnd().getValue();</span>
                // if end appears, then there has to be a start page appeared, so get it and put it together with
                // the end page
<span class="fc" id="L359">                String startPage = fields.get(StandardField.PAGES);</span>
<span class="fc" id="L360">                fields.put(StandardField.PAGES, startPage + &quot;-&quot; + endPage);</span>
            }
        }
<span class="fc" id="L363">    }</span>

    private void putPlaceOrPublisherOrDate(Map&lt;Field, String&gt; fields, String elementName, Object object) {
<span class="fc" id="L366">        Optional&lt;IssuanceDefinition&gt; issuanceDefinition = getElement(object, IssuanceDefinition.class);</span>
<span class="fc" id="L367">        Optional&lt;PlaceDefinition&gt; placeDefinition = getElement(object, PlaceDefinition.class);</span>
<span class="fc" id="L368">        Optional&lt;DateDefinition&gt; dateDefinition = getElement(object, DateDefinition.class);</span>
<span class="fc" id="L369">        Optional&lt;StringPlusLanguagePlusSupplied&gt; publisherOrEdition = getElement(object,</span>
                StringPlusLanguagePlusSupplied.class);

<span class="fc" id="L372">        issuanceDefinition.ifPresent(issuance -&gt; putIfValueNotNull(fields, new UnknownField(&quot;issuance&quot;), issuance.value()));</span>

<span class="fc" id="L374">        List&lt;String&gt; places = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L375">        placeDefinition</span>
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">                .ifPresent(place -&gt; place.getPlaceTerm().stream().filter(placeTerm -&gt; placeTerm.getValue() != null)</span>
<span class="fc" id="L377">                                         .map(PlaceTermDefinition::getValue).forEach(element -&gt; places.add(element)));</span>
<span class="fc" id="L378">        putIfListIsNotEmpty(fields, places, StandardField.ADDRESS, &quot;, &quot;);</span>

<span class="fc" id="L380">        dateDefinition.ifPresent(date -&gt; putDate(fields, elementName, date));</span>

<span class="fc" id="L382">        publisherOrEdition.ifPresent(pubOrEd -&gt; putPublisherOrEdition(fields, elementName, pubOrEd));</span>
<span class="fc" id="L383">    }</span>

    private void putPublisherOrEdition(Map&lt;Field, String&gt; fields, String elementName,
                                       StringPlusLanguagePlusSupplied pubOrEd) {
<span class="fc bfc" id="L387" title="All 2 branches covered.">        if (&quot;publisher&quot;.equals(elementName)) {</span>
<span class="fc" id="L388">            putIfValueNotNull(fields, StandardField.PUBLISHER, pubOrEd.getValue());</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        } else if (&quot;edition&quot;.equals(elementName)) {</span>
<span class="fc" id="L390">            putIfValueNotNull(fields, StandardField.EDITION, pubOrEd.getValue());</span>
        }
<span class="fc" id="L392">    }</span>

    private void putDate(Map&lt;Field, String&gt; fields, String elementName, DateDefinition date) {
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (date.getValue() != null) {</span>
<span class="fc bfc" id="L396" title="All 5 branches covered.">            switch (elementName) {</span>

                case &quot;dateIssued&quot;:
                    // The first 4 digits of dateIssued should be the year
<span class="fc" id="L400">                    fields.put(StandardField.YEAR, date.getValue().replaceAll(&quot;[^0-9]*&quot;, &quot;&quot;).replaceAll(&quot;\\(\\d?\\d?\\d?\\d?.*\\)&quot;, &quot;\1&quot;));</span>
<span class="fc" id="L401">                    break;</span>
                case &quot;dateCreated&quot;:
                    // If there was no year in date issued, then take the year from date created
<span class="fc" id="L404">                    fields.computeIfAbsent(StandardField.YEAR, k -&gt; date.getValue().substring(0, 4));</span>
<span class="fc" id="L405">                    fields.put(new UnknownField(&quot;created&quot;), date.getValue());</span>
<span class="fc" id="L406">                    break;</span>
                case &quot;dateCaptured&quot;:
<span class="fc" id="L408">                    fields.put(new UnknownField(&quot;captured&quot;), date.getValue());</span>
<span class="fc" id="L409">                    break;</span>
                case &quot;dateModified&quot;:
<span class="fc" id="L411">                    fields.put(new UnknownField(&quot;modified&quot;), date.getValue());</span>
<span class="fc" id="L412">                    break;</span>
                default:
                    break;
            }
        }
<span class="fc" id="L417">    }</span>

    private void putIfListIsNotEmpty(Map&lt;Field, String&gt; fields, List&lt;String&gt; list, Field key, String separator) {
<span class="fc bfc" id="L420" title="All 2 branches covered.">        if (!list.isEmpty()) {</span>
<span class="fc" id="L421">            fields.put(key, list.stream().collect(Collectors.joining(separator)));</span>
        }
<span class="fc" id="L423">    }</span>

    private void handleAuthorsInNamePart(NameDefinition name, List&lt;String&gt; authors, Map&lt;Field, String&gt; fields) {
<span class="fc" id="L426">        List&lt;JAXBElement&lt;?&gt;&gt; namePartOrDisplayFormOrAffiliation = name.getNamePartOrDisplayFormOrAffiliation();</span>
<span class="fc" id="L427">        List&lt;String&gt; foreName = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L428">        String familyName = &quot;&quot;;</span>
<span class="fc" id="L429">        String author = &quot;&quot;;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">        for (JAXBElement&lt;?&gt; element : namePartOrDisplayFormOrAffiliation) {</span>
<span class="fc" id="L431">            Object value = element.getValue();</span>
<span class="fc" id="L432">            String elementName = element.getName().getLocalPart();</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">            if (value instanceof NamePartDefinition) {</span>
<span class="fc" id="L434">                NamePartDefinition namePart = (NamePartDefinition) value;</span>
<span class="fc" id="L435">                String type = namePart.getAtType();</span>
<span class="pc bpc" id="L436" title="1 of 4 branches missed.">                if ((type == null) &amp;&amp; (namePart.getValue() != null)) {</span>
<span class="fc" id="L437">                    String namePartValue = namePart.getValue();</span>
<span class="fc" id="L438">                    namePartValue = namePartValue.replaceAll(&quot;,$&quot;, &quot;&quot;);</span>
<span class="fc" id="L439">                    authors.add(namePartValue);</span>
<span class="pc bpc" id="L440" title="1 of 4 branches missed.">                } else if (&quot;family&quot;.equals(type) &amp;&amp; (namePart.getValue() != null)) {</span>
                    // family should come first, so if family appears we can set the author then comes before
                    // we have to check if forename and family name are not empty in case it's the first author
<span class="pc bpc" id="L443" title="3 of 4 branches missed.">                    if (!foreName.isEmpty() &amp;&amp; !familyName.isEmpty()) {</span>
                        // now set and add the old author
<span class="nc" id="L445">                        author = familyName + &quot;, &quot; + Joiner.on(&quot; &quot;).join(foreName);</span>
<span class="nc" id="L446">                        authors.add(author);</span>
                        // remove old forenames
<span class="nc" id="L448">                        foreName.clear();</span>
<span class="pc bpc" id="L449" title="2 of 4 branches missed.">                    } else if (foreName.isEmpty() &amp;&amp; !familyName.isEmpty()) {</span>
<span class="nc" id="L450">                        authors.add(familyName);</span>
                    }
<span class="fc" id="L452">                    familyName = namePart.getValue();</span>
<span class="pc bpc" id="L453" title="1 of 4 branches missed.">                } else if (&quot;given&quot;.equals(type) &amp;&amp; (namePart.getValue() != null)) {</span>
<span class="fc" id="L454">                    foreName.add(namePart.getValue());</span>
                }
<span class="pc bpc" id="L456" title="1 of 4 branches missed.">            } else if ((value instanceof StringPlusLanguage) &amp;&amp; &quot;affiliation&quot;.equals(elementName)) {</span>
<span class="fc" id="L457">                StringPlusLanguage affiliation = (StringPlusLanguage) value;</span>
<span class="fc" id="L458">                putIfValueNotNull(fields, new UnknownField(&quot;affiliation&quot;), affiliation.getValue());</span>
            }
<span class="fc" id="L460">        }</span>

        // last author is not added, so do it here
<span class="pc bpc" id="L463" title="1 of 4 branches missed.">        if (!foreName.isEmpty() &amp;&amp; !familyName.isEmpty()) {</span>
<span class="fc" id="L464">            author = familyName + &quot;, &quot; + Joiner.on(&quot; &quot;).join(foreName);</span>
<span class="fc" id="L465">            authors.add(author.trim());</span>
<span class="fc" id="L466">            foreName.clear();</span>
<span class="pc bpc" id="L467" title="1 of 4 branches missed.">        } else if (foreName.isEmpty() &amp;&amp; !familyName.isEmpty()) {</span>
<span class="fc" id="L468">            authors.add(familyName.trim());</span>
        }
<span class="fc" id="L470">    }</span>

    private void putIfValueNotNull(Map&lt;Field, String&gt; fields, Field field, String value) {
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (value != null) {</span>
<span class="fc" id="L474">            fields.put(field, value);</span>
        }
<span class="fc" id="L476">    }</span>

    @Override
    public String getName() {
<span class="fc" id="L480">        return &quot;MODS&quot;;</span>
    }

    @Override
    public StandardFileType getFileType() {
<span class="fc" id="L485">        return StandardFileType.XML;</span>
    }

    @Override
    public String getDescription() {
<span class="fc" id="L490">        return &quot;Importer for the MODS format&quot;;</span>
    }

    @Override
    public List&lt;BibEntry&gt; parseEntries(InputStream inputStream) throws ParseException {
        try {
<span class="fc" id="L496">            return importDatabase(new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))).getDatabase().getEntries();</span>
<span class="nc" id="L497">        } catch (IOException e) {</span>
<span class="nc" id="L498">            LOGGER.error(e.getLocalizedMessage(), e);</span>
        }
<span class="nc" id="L500">        return Collections.emptyList();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>